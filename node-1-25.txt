面试知识点1-25

一、判断是否是圆内
	function inCircle(cx,cy,x,y,r){
		return (cx-x)^2+(cy-y)^2<r^2
	}

二、箭头函数不能用作 Generator 函数。

	箭头函数适合简单的回调和事件处理，而 Generator 函数适合需要暂停/恢复的复杂异步流程
	上下文绑定：Generator 函数需要维护自己的 this 和调用栈状态，而箭头函数是静态绑定的，无法实现这种动态行为。

	正确写法：
	function* gen() {
	yield 1;
	yield 2;
	}

	const iterator = gen();
	console.log(iterator.next()); // { value: 1, done: false }
	console.log(iterator.next()); // { value: 2, done: false }

三、计算宽度
	布局控制 → offsetWidth/clientWidth
	​视口定位 → getBoundingClientRect()
	​动态样式 → getComputedStyle()
	​滚动逻辑 → scrollWidth
	​SVG 图形 → getBBox()
	​框架开发 → 结合 Ref API 或ResizeObserver


	offsetWidth
	原理：返回元素渲染后的总宽度​（包含内边距、边框，但不含滚动条）

	clientWidth
	原理：返回元素可视区域的宽度​（含内边距，不含边框和滚动条）

	scrollWidth
	原理：返回元素内容总宽度​（含隐藏的溢出内容）

	动态元素尺寸监听：
	javascript
	const observer = new ResizeObserver(entries => {
	entries.forEach(entry => {
		console.log('宽度变化:', entry.contentRect.width);
	});
	});

	observer.observe(document.getElementById('dynamicElement'));

四、BFC是一块块独立的渲染区域，可以将BFC看成是元素的一种属性，
	拥有了这种属性的元素就会使他的子元素与世隔绝，不会影响到外部其他元素

	bfc:display:inline-block、flex

	使用BFC解决子元素浮动导致父元素高度塌陷的机制
	margin重叠机制
	普通元素和浮动元素相互重叠的机制

五、http缓存
	A.强缓存：
		1. expires，废弃，因为本地时间和服务器时间不同步的问题
		2. cache-control  http1.1添加
			'Cache-Control':'max-age=10'
			Cache-control有max-age、s-maxage、no-cache、no-store、private、public这六个属性。

            * no-cache表示是强制进行协商缓存。
            * no-store是表示禁止任何缓存策略。
	B. 协商缓存：
	 1.  last-modified 获取时间， Cache-Control字段值设置为:no-cache
	     判断依据： last-modified === If-Modified-Since 则采用缓存 （存在漏洞，比如只修改文件名、修改时间极短）
	2. e-tag 作为补充。 比较文件指纹，资源内容hash 的信息摘要  。
	   （文件太多就影响性能，所以有强验证和弱验证，弱验证就去文件部份属性进行hash）
	
	304 状态码主要与以下 HTTP 响应头有关：
	一、Last-Modified 和 If-Modified-Since
	二、ETag 和 If-None-Match
	ETag的生成  1 、基于资源内容生成（hash）  2. 基于资源属性生成 （时间戳） 3. 动态生成（服务端逻辑 特定业务）

	状态码：
	301 Moved Permanently（永久重定向）
	302 Found（临时重定向）
    * 测试环境：使用 302 将流量临时导向测试服务器，完成后移除重定向。

	400 Bad Request（错误请求）
	401 Unauthorized（未授权）
	403 Forbidden（禁止访问）
	405 Method Not Allowed（方法不被允许）
	408 Request Timeout（请求超时）
	429 Too Many Requests（请求过多）



六、http 
	1.x： 文本格式，序列和阻塞机制    
	1.1 keep-alive支持长连接 三次握手
	2：     二进制帧层、多路复用、头部压缩、服务器推送、流优先级
			(1) 二进制帧层   二进制数据帧， 帧属于哪个流有标识
			(2) 多路复用（Multiplexing）   无队头阻塞的多路复用，避免旧版的队头阻塞，允许在同一个 TCP 连接上并行发送多个请求和响应, 
			(3) 头部压缩（Header Compression） 对于相同的数据，不再通过每次请求和响应发送
			(4) 服务器推送（Server Push） 
				服务器可以在客户端请求之前，主动将资源推送到客户端。
				减少客户端请求的往返时间（RTT），提升页面加载速度。
			(5) 流优先级（Stream Prioritization）
				客户端可以为请求设置优先级，服务器根据优先级处理请求。
				确保关键资源（如 CSS、JavaScript）优先加载。
	3：   udp， 采用quic协议，无队头阻塞的多路复用，丢包不阻塞
			无队头阻塞的多路复用
			1-RTT建连 ， 0-RTT连接建立   （Round-Trip Time，RTT）
			无歧义重传

		1.  多路复用升级版
		* HTTP/2 的痛点：虽然支持多请求并发（多路复用），但底层 TCP 一旦丢包，所有请求被阻塞。
		* HTTP/3 的改进：QUIC 为每个请求分配独立流（Stream），丢包只影响当前流，其他流正常传输。

		2. 「快递车道」协议（QUIC）
		加密直接集成到协议中（强制 HTTPS）：再次连接：0-RTT 极速恢复
		QUIC 用 连接 ID 标识会话，IP 或网络变化时，无需重新握手，直接继续传输
		QUIC 还支持拥塞控制，它可以根据网络条件调整数据包的发送速率，以避免网络拥塞
		前向安全性
			缺点：
			QUIC协议更容易受到分布式拒绝服务（DDoS）
			兼容性问题
			较小数据包的传输速率较低
			故障排除困难


		Keep-Alive解决的核心问题是： 一定时间内，同一域名多次请求数据，只建立一次 HTTP 请求，其他请求可复用每一次建立的连接通道
		Keep-Alive还是存在如下问题：
		串行的文件传输。
		同域并行请求限制带来的阻塞（6~8）个

七、前端缓存
	需要在客户端和服务器之间传递少量数据，例如登录状态：Cookie。 httpOnly传递token , 4k
	• 需要在客户端长期存储大量数据，例如用户偏好设置：LocalStorage , 5m
	• 需要在客户端临时存储数据，例如填写表单的中间数据：SessionStorage， 5m

	cookie的属性
	* HttpOnly：表示 Cookie 只能通过 HTTP 请求访问，不能通过 JavaScript 访问。
	* Expires：表示 Cookie 的过期时间。
	* Secure：表示 Cookie 只能通过 HTTPS 协议传输。

八、建立TCP连接，三次握手;  确认双方的接收和发送能力
        客户端：你好，你听得到么。（客户端发送能力）
        服务器：你好，我听得到，你听得到么？（服务器：接收能力、响应能力）
        客户端：我也听得到。（客户端接收能力）

   关闭TCP连接，四次挥手； 1. A要断开了，2. B同意， 3. B可以断开 4. A断开

        客户端：我没什么要说的了，我们分手吧。（客户端没有数据发送了）
        服务器：好的，我们分手吧。（服务器同意分手）
        服务器：我也没什么要说的了，我们分手吧。（服务器没有数据推送了）
        客户端：好的，我们分手吧。（客户端知道服务器没有数据了，果断分手）

九、输入网址到网页显示，背后发生了什么？
    1、浏览器解析URL
    2、DNS域名解析
    3、浏览器与服务器建立三次握手
    4、浏览器向服务器发送HTTP请求报文
    5、服务器给浏览器发送HTTP响应报文以及首页的HTML文件
    6、浏览器渲染HTML页面
    7、浏览器和服务器四次挥手，断开连接

    URL解析：浏览器首先会对输入的URL进行解析，包括协议、域名、端口、路径、查询参数等。
    DNS解析：浏览器会通过DNS解析将域名解析为IP地址。
    组装HTTP请求：浏览器会根据解析后的IP地址，组装HTTP请求
    检查缓存：浏览器在发送请求前会检查是否有缓存，有缓存则直接使用缓存，否则发送请求。（html一般不缓存的，这步略过）
    建立TCP连接：浏览器会与服务器建立TCP连接，包括三次握手。
    发送HTTP请求：浏览器会向服务器发送HTTP请求，包括请求行、请求头、请求体等。
    服务器处理请求响应结果：服务器会根据请求的路径和参数，返回相应的资源
    断开TCP连接：浏览器与服务器断开TCP连接，包括四次挥手。
    解析HTML：浏览器会解析HTML，构建DOM树。
    构建CSSOM树：浏览器会解析CSS，构建CSSOM树。
    构建渲染树：浏览器会根据DOM树和CSSOM树，构建渲染树。
    布局渲染树：浏览器会根据渲染树，计算每个节点的位置和大小。
    绘制渲染树：浏览器会根据渲染树，绘制页面。
    链接：https://juejin.cn/post/7404777076089208842


十、垃圾回收机制
    标记清除：可以清除循环引用
    引用计数：缺点：循环引用无法清除，优点：立即清除

	新生代，老生代，新生代里面有form和to， from是活跃变量，之后会复制到to区域


十一、js文件中没有DOM操作，可以将JavaScript脚本设置为异步加载，用async或defer标记代码，
     异步加载脚本，不会阻塞页面渲染。defer顺序可控，（async脚本独立时用）

十二、实例上的__proto__ == 构造函数上的prototype


十三、TLS（Transport Layer Security，传输层安全协议）和 
	SSL（Secure Sockets Layer，安全套接字层）
	tls更安全

十四、
	一、证书颁发机构（CA）的信任体系
    1. 根证书的信任：2. 中间证书的验证：
	二、证书的验证过程
    1. 证书的完整性检查：2. 证书的有效期检查：3. 域名匹配检查：
	三、证书吊销检查
    1. 证书吊销列表（CRL）： 2. 在线证书状态协议（OCSP）：

十五、分片上传文件，如何校验文件完整性
	一、使用哈希算法 : JavaScript 的crypto-js库计算文件的 MD5 哈希值：
	二、校验和（字节总和）
	三、文件大小比较
	四、上传状态跟踪 （收到表示确认）

十六、Object.keys()只返回了可枚举的属性property1和property2，
	而Object.getOwnPropertyNames()返回了所有属性，包括不可枚举的nonEnumerableProperty

十七、Content-Type为application/octet-stream，代表以下含义：
    * application/octet-stream表示这是一个通用的二进制流数据
    * 可以用于传输各种类型的二进制文件，如图片、音频、视频、压缩文件、可执行文件等。

十八、常见性能优化手段
	1. 加载优化
	* 资源压缩：
		* CSS/JS 压缩：移除空格、注释，缩短文件体积（如使用 uglify-js、cssnano）。
		* 图片优化：压缩格式（WebP）、懒加载（loading="lazy"）、CDN 加速。
	* 缓存策略：
		* 强缓存（Cache-Control: max-age=31536000）减少重复下载。
		* 协商缓存（ETag、Last-Modified）。
	* 按需加载	◦	
			* 代码分割：通过 Webpack 的 splitChunks 分割代码。
			* 动态导入：import() 实现按需加载模块。
	1. 渲染优化：减少重绘与重排
	2. 资源优化： Tree Shaking： 图片懒加载： 
	3. 代码优化：避免阻塞渲染：减少第三方脚本：
	4. 网络优化：HTTP/2 或 HTTP/3：DNS 预解析：预连接，合并请求

	* 图片懒加载 + CDN 加速 → 页面加载时间减少 40%。
	* 服务端渲染（SSR） + 预取关键资源 → 首屏时间提升 30%。


十九、性能优化方案：https://juejin.cn/post/7326268947069534234#heading-3
	第一种，启用前端缓存
	第二种，开启GZIP压缩 
	第三种，使用函数节流和函数防抖
	第四种，异步加载script文件或将script文件放在最后加载
	第五种，减少重排和重绘
	第六种，使用服务端渲染
	第七种，将png/jpg/gif图片替换为webp格式图片
	第八种，合并请求
	第九种，启用事件委托（事件代理）
	第十种，尽量使用CSS完成动画效果
	第十一种，适当使用memo --- React篇
	第十二种，使用懒加载
	第十三种，使用骨架屏
	第十四种，将moment.js换成day.js

	Gzip是一种数据压缩算法，用于减少文件大小，加快传输速度。它通过将重复的字符串用更短的代码表示来压缩数据。

	Nginx 流量按比例转发:https://juejin.cn/post/7463871170015019023
	可以通过 加权轮询（Weighted Round Robin） 或 split_clients 模块来实现 流量按比例转发。以下是两种常见的实现方式：

	http {
		upstream backend {
			server backend1.example.com weight=3;  # 权重为 3
			server backend2.example.com weight=2;  # 权重为 2
			server backend3.example.com weight=1;  # 权重为 1
		}

		server {
			listen 80;

			location / {
				proxy_pass http://backend;
			}
		}
	}

	nginx的场景，图片防盗链怎么做，反向代理是什么，怎么做
    图片防盗链实现：Referer字段实现。
    反向代理（Reverse Proxy）
    2.1 核心概念
    反向代理充当客户端与后端服务器之间的中介：

    功能：

    隐藏真实服务器IP，提升安全性。

    负载均衡，分散请求压力。

    缓存静态内容，加速访问。

    SSL终止，集中管理HTTPS证书


二十、Web 安全问题及防御措施
	XSS（跨站脚本攻击）
	CSRF（跨站请求伪造）   后端生成 Token，前端提交时携带。
	SQL 注入
	DDoS（分布式拒绝服务）
	敏感信息泄露


	CSP 通过限制 Web 应用程序能够加载和执行的内容，来减少恶意攻击的成功率 （Content Security Policy）
    DOS攻击通常由单个计算机或机器人网络发起，
    而DDOS攻击则是由多个不同来源的计算机或机器人网络同时攻击，更加难以防御和发现。
    解决办法：流量过滤、负载均衡、加强认证和授权、升级硬件和软件

    utf8 是对 Unicode 的一种压缩算法
	

二十一、不需要等待所有异步操作完成时，可以使用 forEach
	   如果你需要按顺序等待每个异步操作完成，
	   使用 for 循环（或其他支持 await 的循环，如 for...of 或传统的 for 循环）

二十二、try catch : 只能在同步函数或者async函数中使用try...catch。异步函数不行


二十三、服务端向客户端推送数据的实现方案
	1. 轮询。   浏览器请求并发是有限制的 ， 6个最多， 消耗性能
	2. websocket。， 双向通讯的协议。 （聊天）
	3. SSE  ie不支持 ， 一个单向通讯的协议也是一个长链接， 只能服务端主动给客户端推送数据

二十四、预检请求：
		预检请求是 CORS 机制的重要组成部分，用于确保跨域请求的安全性。
			通过合理配置服务器响应头，可以减少预检请求的频率，提升性能。
		预检请求（Preflight Request） 的响应状态码通常是 200 OK。

		这是因为预检请求的目的是确认服务器是否允许实际的跨域请求，而不是实际处理请求。
		服务器通过返回 200 OK 状态码和相关的 CORS 头信息，告诉浏览器是否允许后续的实际请求。


		预检请求失败	403/405 等	服务器不允许跨域请求，浏览器会阻止实际请求。


二十五、虚拟列表的基本原理：（为了流畅滚动）
	虚拟列表通过只渲染当前可视区域内的列表项，从而提高长列表加载到页面的性能。

	1. 设置子数据项高度：确定子数据项的具体高度。以确定当前区域内需要渲染的列表项。
	2. 计算可视区域高度：确定当前可视区域内可渲染多少条子数据项，计算起始下标、结束下标。避免渲染整个列表。
	3. 渲染可视区域：保持渲染的DOM节点数量始终在一个较小的范围内，通过动态调整渲染内容的位置，保持列表高度完整且滚动条能正常滚动。
	4. 滚动监听：监听容器的滚动事件，实时获取滚动位置，通过滚动位置实时更新可视区域范围，动态渲染对应列表项。
	5. 设置缓冲列表项：在可视区域的上下各增加一定数量的缓冲列表项，提前加载即将进入可视区域的列表项，避免滚动时出现空白以及卡顿的情况。

	应用场景不同：
	需要快速打开页面 → 优先懒加载
	需要流畅滚动长列表 → 必须虚拟列表

	懒加载，分页