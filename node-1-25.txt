 知识点1-25

1、同一个页面引入多个版本jQuery实现共存
	jQuery.noConflict()

	$(function(){
		var $2 = $.noConflict(); // 第二个加载的jQuery对象变成了 $2
		var version = $.fn.jquery ;
		var version2 = $2.fn.jquery ;
		console.info(version , version2);
		document.write("jQuery版本是： " + version + "jQuery2版本是： " + version2);
	});


	jq 的链式调用通过以下机制实现：

    ​函数式 API 设计：
    每个 jq 方法（如 map、filter、reduce）均返回一个新的 jq 对象，而非直接修改原始数据。
    这种设计允许将多个操作串联起来，形成流水线式的处理流程。

    jq 的链式调用本质上是 ​函数式编程 和 ​状态封装 的结合：
    ​函数返回新状态：每次操作生成新 jq 对象，保留原始数据不变。
    ​高阶函数：通过 map、filter 等方法将业务逻辑与数据操作解耦。
    ​错误隔离：通过 catch 方法控制异常传播，避免链式崩溃。
    这种设计使得 jq 的代码简洁且易于维护，同时保证了高性能和灵活性。

2、箭头函数不能用作 Generator 函数。

	箭头函数适合简单的回调和事件处理，而 Generator 函数适合需要暂停/恢复的复杂异步流程
	上下文绑定：Generator 函数需要维护自己的 this 和调用栈状态，而箭头函数是静态绑定的，无法实现这种动态行为。

	正确写法：
	function* gen() {
		yield 1;
		yield 2;
	}

	const iterator = gen();
	console.log(iterator.next()); // { value: 1, done: false }
	console.log(iterator.next()); // { value: 2, done: false }


	不需要等待所有异步操作完成时，可以使用 forEach
	如果你需要按顺序等待每个异步操作完成，
	使用 for 循环（或其他支持 await 的循环，如 for...of 或传统的 for 循环）

	try catch : 只能在同步函数或者async函数中使用try...catch。异步函数不行



3、如何setTimeout 实现setInterval
    写一个loop函数，先定义空定时器，里面赋值定时器，定时器里面执行fn和loop，最后返回清除定时器

4、如何实现预览 PDF 文件
        1. 使用浏览器内置的 PDF 查看器

        <!-- 方法1: 使用超链接 -->
        <a href="/path/to/your/document.pdf" target="_blank">预览PDF</a>

        <!-- 方法2: 使用JavaScript -->
        <button onclick="window.open('/path/to/your/document.pdf', '_blank')">预览PDF</button>

        2. 使用 PDF.js


5、小程序特有的双线程设计。 H5 下我们所有资源通常都会打到一个 bundle.js 文件里（不考虑分包加载），
	而小程序编译后的结果会有两个bundle，index.js封装的是小程序项目的 view 层，以及 index.worker.js 封装的是项目的业务逻辑，
	在运行时，会有两条线程来分别处理这两个bundle，一个是主渲染线程，它负责加载并渲染 index.js 里的内容，
	另外一个是 Service Worker线 程，它负责执行 index.worker.js 里封装的业务逻辑，这里面会有很多对底层api调用。


6、垃圾回收机制
    标记清除：可以清除循环引用
    引用计数：缺点：循环引用无法清除，优点：立即清除

	新生代，老生代，新生代里面有form和to， from是活跃变量，之后会复制到to区域


7、js文件中没有DOM操作，可以将JavaScript脚本设置为异步加载，用async或defer标记代码，
     异步加载脚本，不会阻塞页面渲染。defer顺序可控，（async脚本独立时用）

8、代码规范大体可以分为目录规范、编码规范、提交规范。更重要的内容是介绍如何使用相应的工具来检查代码规范，保证项目的健康性。大体归纳如下：

-   编码规范： ESLint （语法） + Prettier（格式）+ Husky (提交时自动检查)；
-   提交 Message ： commitlint(提交信息样式检查) + Husky (提交时自动检查)。


9、分片上传文件，如何校验文件完整性
	一、使用哈希算法 : JavaScript 的crypto-js库计算文件的 MD5 哈希值：
	二、校验和（字节总和）
	三、文件大小比较
	四、上传状态跟踪 （收到表示确认）

10、Object.keys()只返回了可枚举的属性property1和property2，
	而Object.getOwnPropertyNames()返回了所有属性，包括不可枚举的nonEnumerableProperty

11、Content-Type为application/octet-stream，代表以下含义：
    * application/octet-stream表示这是一个通用的二进制流数据
    * 可以用于传输各种类型的二进制文件，如图片、音频、视频、压缩文件、可执行文件等。


12、Web 安全问题及防御措施
	XSS（跨站脚本攻击）
	CSRF（跨站请求伪造）   后端生成 Token，前端提交时携带。
	SQL 注入
	DDoS（分布式拒绝服务）
	敏感信息泄露


	CSP 通过限制 Web 应用程序能够加载和执行的内容，来减少恶意攻击的成功率 （Content Security Policy）
    DOS攻击通常由单个计算机或机器人网络发起，
    而DDOS攻击则是由多个不同来源的计算机或机器人网络同时攻击，更加难以防御和发现。
    解决办法：流量过滤、负载均衡、加强认证和授权、升级硬件和软件

    utf8 是对 Unicode 的一种压缩算法

13、
	预加载原理：在加载页面的同时，用第二个线程加载图片，
		当图片加载完毕后，将图片资源交给第一个线程去展示，从而实现图片的预加载
	缺点：懒加载会出现白屏是因为图片发送http请求需要时间，
		预加载同样也需要这样的话它的白屏时间就会集中出现在开始加载的时候

	懒加载是‘懒人’的好帮手，等你需要的时候才会加载资源，节省了流量和时间，让用户体验更流畅。
	预加载则是‘提前量’的高手，预先加载资源，给用户带来更快的访问速度和更好的体验

14、虚拟列表的基本原理：（为了流畅滚动）
	虚拟列表通过只渲染当前可视区域内的列表项，从而提高长列表加载到页面的性能。

	1. 设置子数据项高度：确定子数据项的具体高度。以确定当前区域内需要渲染的列表项。
	2. 计算可视区域高度：确定当前可视区域内可渲染多少条子数据项，计算起始下标、结束下标。避免渲染整个列表。
	3. 渲染可视区域：保持渲染的DOM节点数量始终在一个较小的范围内，通过动态调整渲染内容的位置，保持列表高度完整且滚动条能正常滚动。
	4. 滚动监听：监听容器的滚动事件，实时获取滚动位置，通过滚动位置实时更新可视区域范围，动态渲染对应列表项。
	5. 设置缓冲列表项：在可视区域的上下各增加一定数量的缓冲列表项，提前加载即将进入可视区域的列表项，避免滚动时出现空白以及卡顿的情况。

	应用场景不同：
	需要快速打开页面 → 优先懒加载
	需要流畅滚动长列表 → 必须虚拟列表

	懒加载，分页