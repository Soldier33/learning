 知识点1-25

# 1、同一个页面引入多个版本jQuery实现共存
	jQuery.noConflict()

	$(function(){
		var $2 = $.noConflict(); // 第二个加载的jQuery对象变成了 $2
		var version = $.fn.jquery ;
		var version2 = $2.fn.jquery ;
		console.info(version , version2);
		document.write("jQuery版本是： " + version + "jQuery2版本是： " + version2);
	});


	jq 的链式调用通过以下机制实现：

    ​函数式 API 设计：
    每个 jq 方法（如 map、filter、reduce）均返回一个新的 jq 对象，而非直接修改原始数据。
    这种设计允许将多个操作串联起来，形成流水线式的处理流程。

    jq 的链式调用本质上是 ​函数式编程 和 ​状态封装 的结合：
    ​函数返回新状态：每次操作生成新 jq 对象，保留原始数据不变。
    ​高阶函数：通过 map、filter 等方法将业务逻辑与数据操作解耦。
    ​错误隔离：通过 catch 方法控制异常传播，避免链式崩溃。
    这种设计使得 jq 的代码简洁且易于维护，同时保证了高性能和灵活性。

# 2、“编译时”和“运行时”

	Vue 是一个编译时和运行时同时存在的框架，
	编译时说白了就是代码运行在 Node.js 阶段，
	运行时代码跑在在浏览器中

	运行时就是代码执行在浏览器的阶段。
	编译时就是代码跑在node.js的阶段，比如执行yarn dev或者yarn build时代码在node.js中执行的阶段


# 3、如何setTimeout 实现setInterval
    写一个loop函数，先定义空定时器，里面赋值定时器，定时器里面执行fn和loop，最后返回清除定时器

# 4、如何实现预览 PDF 文件
        1. 使用浏览器内置的 PDF 查看器

        <!-- 方法1: 使用超链接 -->
        <a href="/path/to/your/document.pdf" target="_blank">预览PDF</a>

        <!-- 方法2: 使用JavaScript -->
        <button onclick="window.open('/path/to/your/document.pdf', '_blank')">预览PDF</button>

        2. 使用 PDF.js


# 5、小程序特有的双线程设计。 H5 下我们所有资源通常都会打到一个 bundle.js 文件里（不考虑分包加载），
	而小程序编译后的结果会有两个bundle，index.js封装的是小程序项目的 view 层，以及 index.worker.js 封装的是项目的业务逻辑，
	在运行时，会有两条线程来分别处理这两个bundle，一个是主渲染线程，它负责加载并渲染 index.js 里的内容，
	另外一个是 Service Worker线 程，它负责执行 index.worker.js 里封装的业务逻辑，这里面会有很多对底层api调用。


# 6、垃圾回收机制
    标记清除：当变量离开上下文时， 也会被加上离开上下文的标记
			1. 实现简单，打标记也就是打或者不打两种可能，所以就一位二进制位就可以表示;
			2. 解决了循环引用的问题;

			缺点：
			1. 内存碎片化(内存零零散散的存放，造成资源浪费);
			2. 再分配时遍次数多，如果一直没有找到合适的内存块大小，那么会遍历空闲链表
				(保存堆中所有空闲地址空间的地址形成的链表）一直遍历到尾端;
			3. 不会立即回收资源;
    引用计数：缺点：1. 循环引用无法清除，2. 时间开销大，因为引用计数算法需要维护引用数
			优点：立即清除


	V8 垃圾回收策略:基于 分代式垃圾回收策略，其根据对象的存活时间将内存的垃圾回收进行不同的分代
	新生代，老生代，新生代里面有form和to， from是活跃变量，之后会复制到to区域


# 7、js文件中没有DOM操作，可以将JavaScript脚本设置为异步加载，用async或defer标记代码，
     异步加载脚本，不会阻塞页面渲染。defer顺序可控，（async脚本独立时用）

# 8、代码规范大体可以分为目录规范、编码规范、提交规范。更重要的内容是介绍如何使用相应的工具来检查代码规范，保证项目的健康性。大体归纳如下：

-   编码规范： ESLint （语法） + Prettier（格式）+ Husky (提交时自动检查)；
-   提交 Message ： commitlint(提交信息样式检查) + Husky (提交时自动检查)。


# 9、分片上传文件，如何校验文件完整性
	一、使用哈希算法 : JavaScript 的crypto-js库计算文件的 MD5 哈希值：
	二、校验和（字节总和）
	三、文件大小比较
	四、上传状态跟踪 （收到表示确认）

# 10、Object.keys()只返回了可枚举的属性property1和property2，
	而Object.getOwnPropertyNames()返回了所有属性，包括不可枚举的nonEnumerableProperty

# 11、Content-Type为application/octet-stream，代表以下含义：
    * application/octet-stream表示这是一个通用的二进制流数据
    * 可以用于传输各种类型的二进制文件，如图片、音频、视频、压缩文件、可执行文件等。

# 12、Web 安全问题及防御措施
	XSS（跨站脚本攻击）
	CSRF（跨站请求伪造）   后端生成 Token，前端提交时携带。
	SQL 注入
	DDoS（分布式拒绝服务）
	敏感信息泄露


	CSP 通过限制 Web 应用程序能够加载和执行的内容，来减少恶意攻击的成功率 （Content Security Policy）
    DOS攻击通常由单个计算机或机器人网络发起，
    而DDOS攻击则是由多个不同来源的计算机或机器人网络同时攻击，更加难以防御和发现。
    解决办法：流量过滤、负载均衡、加强认证和授权、升级硬件和软件

    utf8 是对 Unicode 的一种压缩算法

# 13、
	预加载原理：在加载页面的同时，用第二个线程加载图片，
		当图片加载完毕后，将图片资源交给第一个线程去展示，从而实现图片的预加载
	缺点：懒加载会出现白屏是因为图片发送http请求需要时间，
		预加载同样也需要这样的话它的白屏时间就会集中出现在开始加载的时候

	懒加载是‘懒人’的好帮手，等你需要的时候才会加载资源，节省了流量和时间，让用户体验更流畅。
	预加载则是‘提前量’的高手，预先加载资源，给用户带来更快的访问速度和更好的体验

# 14、虚拟列表的基本原理：（为了流畅滚动）
	虚拟列表通过只渲染当前可视区域内的列表项，从而提高长列表加载到页面的性能。

	1. 设置子数据项高度：确定子数据项的具体高度。以确定当前区域内需要渲染的列表项。
	2. 计算可视区域高度：确定当前可视区域内可渲染多少条子数据项，计算起始下标、结束下标。避免渲染整个列表。
	3. 渲染可视区域：保持渲染的DOM节点数量始终在一个较小的范围内，通过动态调整渲染内容的位置，保持列表高度完整且滚动条能正常滚动。
	4. 滚动监听：监听容器的滚动事件，实时获取滚动位置，通过滚动位置实时更新可视区域范围，动态渲染对应列表项。
	5. 设置缓冲列表项：在可视区域的上下各增加一定数量的缓冲列表项，提前加载即将进入可视区域的列表项，避免滚动时出现空白以及卡顿的情况。

	应用场景不同：
	需要快速打开页面 → 优先懒加载
	需要流畅滚动长列表 → 必须虚拟列表

	懒加载，分页

	vue实现：https://juejin.cn/post/7449930918079545379

# 15. 退出浏览器之间， 发送积压的埋点数据请求， 该如何做
	使用 navigator.sendBeacon()
	使用 fetch() API 与 keepalive 选项

	1. navigator.sendBeacon 
	发送一些统计数据到服务器的简单示例：

	window.addEventListener("unload", function () {
	var data = { action: "leave", timestamp: Date.now() };
	navigator.sendBeacon("https://example.com/analytics", JSON.stringify(data));
	});
	在上面的例子中，当用户离开页面时，我们监听 unload 事件，并在该事件触发时使用 navigator.sendBeacon() 方法发送一些统计数据到服务器


	2. keepalive 选项在 fetch 请求中的作用主要是允许在浏览器即将关闭或者用户即将离开当前页面时，仍然能够成功发送网络请求。
	这个选项的设计初衷是为了处理那些需要在页面生命周期结束时发送的统计或追踪数据的场景，比如用户的行为追踪数据、性能数据等。

	window.addEventListener("beforeunload", (event) => {
	// 构造你想要发送的数据
	const data = {
		// ...一些追踪数据
	};

	// 发送请求到服务器
	fetch("https://yourserver.com/api/track", {
		method: "POST",
		body: JSON.stringify(data),
		headers: {
		"Content-Type": "application/json",
		},
		keepalive: true, // 使用 keepalive 选项
	});
	});

# 16. websocket 断联之后如何重连，且保证断链期间数据不丢失

	1. 监听连接状态
	2. 实现重连逻辑
	3. 缓存数据
	4. 发送缓存数据

# 17。 如何开启 ts 类型强校验，ts 类型错误 webpack 直接编译失败
	1. 开启 TS 严格模式
	2. 使用ForkTsCheckerWebpackPlugin并配置使编译失败

# 18. PWA优化策略
	简言之：在你第一次访问一个网站的时候，如果成功，做一个缓存，当服务器挂了之后，
	你依然能够访问这个网页 ，这就是PWA。那相信你也已经知道了，
	这个只需要在生产环境，才需要做PWA的处理，以防不测。


	cnpm i workbox-webpack-plugin -D

	const WorkboxPlugin = require('workbox-webpack-plugin') // 引入 PWA 插件
	const prodConfig = {
	plugins: [
		// 配置 PWA
		new WorkboxPlugin.GenerateSW({
		clientsClaim: true,
		skipWaiting: true
		})
	]
	}

	在入口文件加上
	// 判断该浏览器支不支持 serviceWorker
	if ('serviceWorker' in navigator) {
	window.addEventListener('load', () => {
		navigator.serviceWorker
		.register('/service-worker.js')
		.then(registration => {
			console.log('service-worker registed')
		})
		.catch(error => {
			console.log('service-worker registed error')
		})
	})
	}

	配置完后，你可以打包到dist目录下，在dist目录下启动一个静态服务器，访问首页，
	然后关闭这个服务器，你会惊讶的发现：网站竟然还能够访问，哈哈，是不是很神奇？


# 19. V8 里面的 JIT 是什么？
	JIT 是“Just-In-Time”（即时编译）的缩写，它是一种提高代码执行性能的技术。
	具体来说，在 V8 引擎（Google Chrome 浏览器和 Node.js 的 JavaScript 引擎）中，
	JIT 编译器在 JavaScript 代码运行时，将其编译成机器语言，以提高执行速度。

	解释执行
	即时编译
	优化与去优化

# 20. 使用 requestIdleCallback，开发者可以更好地利用浏览器的空闲序列来执行不紧急的任务，同时保持用户交互的流畅度。

 ​# 21. 渲染超大规模数据Dom : 
	Canvas 通过直接操作像素和 GPU 加速，能够显著提升渲染效率。以下是使用 Canvas 渲染超大规模数据的核心策略和优化技巧

	优化方向：减少绘制调用次数，利用批量操作和硬件加速。

	1. 离屏 Canvas（Offscreen Canvas）​
	2. 批量绘制（Batch Rendering）
	3. 数据分块与视口裁剪
	4. WebGL 加速


	怎么处理大批量dom数据的情况:
	​DOM 操作昂贵：频繁增删改 DOM 会触发浏览器的 ​重排（Reflow）​ 和 ​重绘（Repaint）​。
	​内存压力：大量 DOM 节点占用内存，可能导致页面崩溃。
	​渲染阻塞：浏览器主线程被占据，导致交互延迟。


		虚拟滚动
		分页或懒加载
		批量操作 DOM
		优化 CSS 和布局

	​减少布局抖动：避免在 JavaScript 中频繁读取布局属性（如 offsetWidth），改用 ResizeObserver。
	​简化样式：避免复杂的 CSS 动画和 box-shadow 等性能消耗大的属性。
	​使用 will-change：提示浏览器提前优化特定元素：

# 22. blob对象
	表示二进制类型的大对象
blob对象实现文件下载
blob使用场景：
	分片上传
	从互联网下载数据
	blob用作url
	blob转换为Base64
	图片压缩
	生成pdf
	blob与ArrayBuffer的区别


# 23. 首屏渲染

1. 性能监听对象 ， 监测时间
    1. performanceObserver
2. 异步组件，这样不需要加载这个组件的资源
3. 骨架屏,mount执行挂载，然后才会替换<div id="app”> 里面的内容


# 24. 大数据渲染： 
虚拟列表、 
分批渲染， 把数据分为二维数组，然后调用requestAnimationFrame分堆渲染，达到不卡顿的情况
懒加载触底加载

	Tips:
	requestAnimationFrame是浏览器用于定时循环操作的一个API,
	通常用于动画和游戏开发。它会把每一帧中的所有DOM操作集中起来,
	在重绘之前一次性更新,并且关联到浏览器的重绘操作。



# 25. 在表单校验场景中， 如何实现页面视口滚动到报错的位置【热度: 248】

	// 滚动到出现问题的元素位置
      var element = document.getElementById(key);
      element.scrollIntoView({ block: "center", behavior: "smooth" });
# 26. 大文件上传：
		创建分片数据
		文件内容创建hash
		调用发生分片接口

		断点续传
		web-worker，多线程切片
		blob存储到IndexedDB

# 27. 实现懒加载：IntersectionObserver （可以做：1.图片懒加载， 2.埋点曝光）
export const useInView = (ref: Ref) => {
  const observer = new IntersectionObserver(callback, options);

  onMounted(() => {
    Object.keys(ref.value).forEach((e) => observer.observe(ref.value[e]));
  });
};

# 28. requestAnimationFrame + fragment（时间分片）

	原理其实就是 通过 requestAnimationFrame 实现分块儿加载。

	requestAnimationFrame + fragment（时间分片）

	requestAnimationFrame也是个定时器，不同于setTimeout，
	它的时间不需要我们人为指定，这个时间取决于当前电脑的刷新率，如果是 60Hz ，那么就是 16.7ms 执行一次，如果是 120Hz 那就是 8.3ms 执行一次

	因此requestAnimationFrame也是个宏任务，前阵子面试就被问到过这个

	fragment是虚拟文档碎片，我们一次for循环产生 20 个li的过程中可以全部把真实dom挂载到fragment上，
	然后再把fragment挂载到真实dom上，这样原来需要回流十万次，现在只需要回流100000 / 20次


		requestAnimationFrame 的优化原理
		​1. 与显示器刷新率同步

		​机制：
		requestAnimationFrame 的回调会在浏览器 ​下一次重绘前 执行（通常是每秒 60 次，即每帧 16.67ms），确保动画的每一帧与屏幕刷新同步。
		​优势：
		避免因 JavaScript 执行时机不当导致的画面撕裂或跳帧。
		​2. 减少布局抖动（Layout Thrashing）​

		​问题：
		频繁读写布局属性（如 offsetWidth 和 style.width）会强制浏览器多次执行布局计算。
		​解决方案：
		requestAnimationFrame 将读写操作集中在同一帧内，减少布局抖动：

# 29. 水印：
	明水印：可以背景、SVG、 canvas
	暗水印：服务端做，将信息写进文件二进制代码中，需要保证文件不变

# 30. 
	DNS协议，将域名映射到ip上

	闭包，方法里面返回一个方法，意义，延长变量生命周期 ，创建私有环境
	存在内存当中，但是外部是用不了的，防抖节流就是闭包
	之前没有class, 没办法创建私有变量，所以用闭包


	全局变量会污染，不能回收

	BigInt 超过最大数字， decimal.js 格式化

# 31. 副作用，影响外部的状态  或  依赖外部状态， 存在不可预测
	纯函数不会修改外部的状态，不会依赖外部状态

# 32. G6
	draw 与 render 的选择
	使用 draw() 当:
	仅修改了元素样式或状态，不需要重新计算位置
	性能敏感，希望避免不必要的布局计算
	使用 render() 当:
	初始化图表
	更改了布局配置
	添加或删除了大量节点/边
	需要重新计算所有元素位置
# 33. 为什么不建议你对图片开启Gzip压缩？
	gzip 是无损压缩，压缩后可通过某种算法操作得到原本的数据（这个过程就是所谓的解压缩）。

	tinypng 背后用的技术是有损压缩，以牺牲图片质量和色彩信息为代价，
	过程是不可逆的，也就是你无法通过某种算法再得到压缩前的数据。


	gzip 的核心是 Deflate，
	而它使用了 LZ77 算法与 Huffman 编码来压缩文件，重复度越高的文件可压缩的空间就越大

	deflate算法会先使用LZ77算法对文件压缩，然后会使用Huffman编码再次压缩，
	最终会得到压缩后的文件，重复度越高的文件可压缩的空间就会越大。

	我们常见的主流图片格式Jpg、Png、Gif等，其实已经用过压缩算法了，当你开启Gzip压缩
	再次进行压缩非但不会减少体积
	还可能因为增加了文件头尾信息部分导致总体积反而变大了。

# 34. base64
	使用base64直接把图片编码成字符串写入CSS文件
# 35. pnpm
	硬链接： 电脑文件系统中的多个文件平等的共享同一个文件存储单元。
	        硬链接就像文件的别名，多个文件名共享同一块物理存储：
	软链接（符号连接）： 包含一条以绝对路径或相对路径的形式指向其他文件或者目录的引用。
	     桌面的快捷方式	



	快速：pnpm 安装依赖的速度通常比 npm 和 yarn 快 2 倍以上，特别是在处理大型项目时，这种优势更为明显
	创新的磁盘空间利用：pnpm 采用内容寻址存储机制，所有依赖包存储在一个集中位置，项目的 node_modules 中只包含指向这个存储的硬链接，大幅减少了重复存储相同依赖的空间浪费
	支持 monorepo：pnpm 内置工作区（workspace）功能，让多包仓库管理变得简单高效，无需额外工具即可处理相互依赖的多个包
	严格的依赖隔离：pnpm 创建非扁平化的 node_modules 结构，确保项目只能访问 package.json 中明确声明的依赖，从根本上解决了"幽灵依赖"问题，提高了项目的稳定性和安全性

# 35. 微前端
JS沙箱的核心在于修改js作用域和重写window