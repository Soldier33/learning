1. SSR: 把js渲染的工作放在服务端做， 
    缺点：开发复杂，服务器压力大，状态管理复杂
	客户端渲染缺点：没办法做seo,没办法做极致的首屏渲染优化
    概念：
	前后端同构
	预渲染
	混合式渲染

	约定式路由

	实现ssr框架：
	注水、脱水

	React
	服务端：renderToString
	客户端：hydrateRoot

	Vue
	服务端：renderToString
	客户端：new Vue

a. “同构开发”，服务端渲染时，
    Nuxt 实际上是在服务器上执行 Vue，
    将我们编写的组件渲染为 HTML
    并返回客户端。客户端激活时执行的 JS 实际上也是
    Vue，它会重新接管文档，恢复数据和状态，
    使静态页面变得可交互，这一过程称为“注水(hydration)”。



2. Nuxt 提供了 5 种渲染模式：

  * 服务端渲染 SSR；
  * 客户端渲染 SPA；
  * 全静态内容生成 SSG；
  * 混合渲染模式 Hybrid；   根据不同路由规则使用不同方式渲染的模式
  * 边缘渲染 Edge-render。

  Nuxt3 提供了跨平台支持，能够同时运行在 Node.js、Deno、Workers 等运行时环境。
  边缘渲染 - edge-side rendering，这种方式能够在 CDN edge worker
    环境下直接执行渲染，这样 Nuxt 应用能够运行在离用户更近的环境中，从而降低延迟和服务器花销。
    需要深度优化应用打开和交互速度，例如：实时游戏，交易系统，就可以尝试边缘渲染模式** 。

 * 客户端渲染：开发速度快，节约服务器资源；首屏慢，SEO 不友好；
  * 服务端渲染：首屏快，SEO 友好，适应性强；开发约束大，服务器费用高；
  * 静态站点生成：首屏极快，SEO 友好，服务器成本低；适应性弱，可维护性差；
  * 混合渲染：按需渲染，适应性强，可维护性好；稳定性、可用性不好；
  * 边缘渲染：性能好，服务器成本低；稳定性、可用性不好。


  * 嵌套路由；如果存在目录和文件同名，就制造了嵌套路由，detail/[id].vue'

  * 动态路由；detail-[id].vue

3. 
    getRouterParam()、readBody()、getQuery()
    getCookie()、 getMethod()、getHeader()

  * 首屏渲染，调用发生在服务端；
  * 客户端激活之后，调用发生在客户端。


  a. 数据获取的任务之后，
  1.  **`$fetch`** **，它全局可用，可以智能处理调用时机，还能统一 API，避免配置代理** 。
  2. ### useFetch

    页面、组件或者插件中可以使用`useFetch`获取任意 URL
    资源。`useFetch`是对`useAsyncData`和`$fetch`的封装，只需传入请求的 URL
    或者一个请求函数即可，一些选项会自动填入，用起来最简洁，是最推荐的数据获取方式。
  3. 刷新数据
    参数没有发生变化，我们实际上拿到的还是之前缓存的结果
    所以需要加参数
        // url需要改为由函数返回
        const { data, refresh } = useFetch(() => `/api/somedata?page=${page}`)
        // 数据刷新！
        page++
        refresh()
  b.  下一步就是状态管理

    * Nuxt 内置的状态管理模块 `useState()`；

    * 整合全局状态管理库：Pinia。

    useState(key, init) 是有缓存性的，如果 key 不变，init 只做初始化，
    则多次调用同一个 useState，结果是一样的；

    服务端友好性，得益于缓存性，即便 init 返回值是不稳定的，
    也能保证前端注水时前后端状态的一致性。

4. ## 三种错误类型

Nuxt3 是全栈框架，代码可能运行在客户端和服务端，因此错误类型可分为以下三种情况：

  * Vue 渲染过程中的错误（包括客户端和服务端）；

  * Nitro 引擎内部运行时错误；

  * 服务器和客户端启动错误（包括客户端和服务端）


5.   三种常见的配置方式：
  * nuxt.config.ts：覆盖或扩展默认 Nuxt 配置；

  * app.config.ts：配置公共变量；

  * 外部配置文件：配置项目中其他方面。



Nuxt 只认 `nuxt.config.ts`，因此一些大家熟悉的独立配置文件会被忽略，作为替代，nuxt.config.ts
中会有对应的配置项，我们来看一下都有哪些：

  * ~~nitro.config.ts~~ ：不能使用，使用 nitro 选项配置；
  * ~~postcss.config.js~~ ：不能使用，使用 postcss 选项配置；
  * ~~vite.config.ts~~ ：不能使用，使用 vite 选项配置；
  * ~~webpack.config.ts~~ ：不能使用，使用 webpack 选项配置。

当然，还有一些配置文件依然可以使用：

  * tsconfig.json；

  * .eslintrc.js；

  * .prettieerrc.json；

  * .stylelintrc.json；

  * tailwind.config.js；

  * vitest.config.js。


6. Nuxt 整合了 Vue、Nitro 前后端两个运行时，
再加上它自身的创建过程，因此框架生命周期钩子分为三类：

  * Nuxt 钩子；

  * Vue App 钩子；

  * Nitro App 钩子。