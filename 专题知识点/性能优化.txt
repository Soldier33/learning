# 1. 常见性能优化手段
	1. 加载优化
	* 资源压缩：
		* CSS/JS 压缩：移除空格、注释，缩短文件体积（如使用 uglify-js、cssnano）。
		* 图片优化：压缩格式（WebP）、懒加载（loading="lazy"）、CDN 加速。
	* 缓存策略：
		* 强缓存（Cache-Control: max-age=31536000）减少重复下载。
		* 协商缓存（ETag、Last-Modified）。
	* 按需加载	◦	
			* 代码分割：通过 Webpack 的 splitChunks 分割代码。
			* 动态导入：import() 实现按需加载模块。
	1. 渲染优化：减少重绘与重排
	2. 资源优化： Tree Shaking： 图片懒加载： 
	3. 代码优化：避免阻塞渲染：减少第三方脚本：
	4. 网络优化：HTTP/2 或 HTTP/3：DNS 预解析：预连接，合并请求

	* 图片懒加载 + CDN 加速 → 页面加载时间减少 40%。
	* 服务端渲染（SSR） + 预取关键资源 → 首屏时间提升 30%。


# 2、性能优化方案：https://juejin.cn/post/7326268947069534234#heading-3
	第一种，启用前端缓存
	第二种，开启GZIP压缩 
	第三种，使用函数节流和函数防抖
	第四种，异步加载script文件或将script文件放在最后加载
	第五种，减少重排和重绘
	第六种，使用服务端渲染
	第七种，将png/jpg/gif图片替换为webp格式图片
	第八种，合并请求
	第九种，启用事件委托（事件代理）
	第十种，尽量使用CSS完成动画效果
	第十一种，适当使用memo --- React篇
	第十二种，使用懒加载
	第十三种，使用骨架屏
	第十四种，将moment.js换成day.js

	Gzip是一种数据压缩算法，用于减少文件大小，加快传输速度。它通过将重复的字符串用更短的代码表示来压缩数据。

# 3. Nginx 流量按比例转发:

更多内容：https://juejin.cn/post/7463871170015019023
	可以通过 加权轮询（Weighted Round Robin） 或 split_clients 模块来实现 流量按比例转发。以下是两种常见的实现方式：

	http {
		upstream backend {
			server backend1.example.com weight=3;  # 权重为 3
			server backend2.example.com weight=2;  # 权重为 2
			server backend3.example.com weight=1;  # 权重为 1
		}

		server {
			listen 80;

			location / {
				proxy_pass http://backend;
			}
		}
	}

	nginx的场景，图片防盗链怎么做，
    图片防盗链实现：Referer字段实现。

	比如有些网站不允许图片外链，只有自家的网站才能显示图片，外部网站加载图片就会报错。
	它的实现就是基于Referer字段，如果该字段的网址是自家网址，就放行

    反向代理（Reverse Proxy）
    反向代理充当客户端与后端服务器之间的中介：

    功能：
    隐藏真实服务器IP，提升安全性。
    负载均衡，分散请求压力。
    缓存静态内容，加速访问。
    SSL终止，集中管理HTTPS证书

3. 白屏 < 1s, 首屏 < 1.5s, onload < 3s

首屏时间，拆分为：白屏时间、数据接口响应时间、图片加载时间
白屏时间，

4. 跨域：5个方式
CORS（跨域资源共享）、jsonp 、 
代理服务器（开发环境（Webpack Dev Server））、 
nginx反向代理、postmessage


在 Nginx 配置文件中设置反向代理，将客户端请求转发到目标服务器。
server {
    listen 80;
    server_name yourdomain.com;

    location /api {
        proxy_pass http://example.com;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}

postMessage 是 HTML5 提供的跨窗口通信 API，可以在不同窗口或 iframe 之间进行跨域通信。

const targetWindow = window.parent; // 假设在 iframe 中
const message = '跨域消息';
targetWindow.postMessage(message, 'http://example.com');

window.addEventListener('message', (event) => {
    if (event.origin === 'http://yourdomain.com') {
        console.log(event.data);
    }
});


5. 数据缓存：
	Service Worker ： 本质是请求代理层，拦截和请求网络
	对于数据时效性不高的，数据可以存储在本地
	CDN

	静态资源强缓存，配置合理的过期时间

	页面重定向：服务器302， meta标签实现重定向，window.location


- Web Worker ：是 HTML5 提供的一种在浏览器中实现多线程的方式。它允许开发者
  将一些耗时的操作放在后台线程中执行，从而避免阻塞主线程，提高页面的响应性能。
- Service Worker ：是一种特殊的 Web Worker，它在浏览器和网络之间充当代理服务器的角色。主要用于实现离线缓存、消息推送和后台同步等功能。
6. 
构建dom树的瓶颈点：
标签缺失，浏览器就会纠错
script会暂停dom的构造过程
dom节点数量过多
外部script能延迟就在就延迟加载


布局的瓶颈点：
设置默认图片大小，才能减少重排
渲染修改了一个元素的属性，会检查所有元素

7. 
SSR: 对于单页应用
页面访问头是爬虫，就走服务端模版
如果是个人用户，就走单页应用

8.
弱网环境：
合并请求
小图标用base64
不自动加载图片，只显示占位图

9. Chrome DevTools
内外网环境、设备不同

SPA 下 Performance不准、用MutationObserver采集首屏时间

10.
懒加载、缓存 强缓存
、离线化 webpack 
、并行化 http2 nginx

11. 
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>开启 DNS 预解析</title>
    <!-- 对指定域名开启 DNS 预解析 -->
    <link rel="dns-prefetch" href="https://example.com">


	适合在页面加载时提前解析外部资源的域名


12. 资源预加载：强缓存
尽量使用同域名、加载快

