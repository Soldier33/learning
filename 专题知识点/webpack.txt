[webpack] 如何优化产物大小 https://github.com/pro-collection/interview-question/issues/887

A、 功能
1. 使用 Tree Shaking   清除未引用代码
2. 启用压缩(Uglification)  如删除未使用的代码、缩短变量名等
3. 代码分割(Code Splitting)   可以把代码分成多个 bundle，然后按需加载，从而减少初始加载时间
4. 使用 Externals 减轻体积
5. 利用缓存(Caching)  [contenthash] 替换 [hash] 或 [chunkhash] 来为输出文件命名，只有当文件内容改变时，文件名称才改变
6. 移除未使用的 CSS 自动去除未使用的 CSS
7. 优化图片   image-webpack-loader等图片压缩插件，可以减小图片文件的体积

二、webpack 中有三种生成哈希值规则的方式，可以用来区分文件是否修改。
* hash 与整个项目有关，项目里有文件修改，所有文件的哈希值都会变化。
* chunkhash 与入口有关，同一入口的文件被视为一个整体，当其中一个文件修改时，同入口的所有文件哈希值发生改变。
* contenthash 只与文件内容有关，文件内容发生改变，才会更改该文件的哈希值

三、Loader 和 Plugin 的区别
					Loader						Plugin
典型应用	处理 CSS、图片、字体等资源	  代码压缩、资源管理、环境变量注入等
配置方式	在 module.rules 中配置	     在 plugins 中配置
作用	    转换模块的源代码			  扩展 Webpack 的功能
输入/输出	接收源文件，返回转换后的内容   不直接处理文件，而是操作构建过程
Loader：用于转换模块的源代码。适合处理文件级别的任务（如 CSS、图片、字体等）。通过 module.rules 配置。
Plugin：用于扩展 Webpack 的功能。适合处理构建过程级别的任务（如代码压缩、资源优化等）。通过 plugins 配置。


四、替换字符串
    方案	适用场景	配置复杂度	性能影响	插件依赖
    DefinePlugin	简单宏替换	★★☆	★★	无
    ReplacePlugin	复杂模式匹配	★★★	★★	✔️
    (replace-webpack-plugin)
    (string-replace-webpack-plugin)
    HtmlWebpackPlugin	HTML 文件占位符替换	★★☆	★★	✔️
    Environment Variables	环境变量注入	★★☆	★★	✔️（dotenv）
    Custom Loader	特定文件深度处理	★★★★	★★★	✔️

五、Webpack 和 vite 的原理  (热更新就是更新受影响的模块，但是不刷新页面)
	1. Webpack 核心是项目整体打包，将多个文件打包成一个，首次加载时间过长，bundle文件
	webpack热更新复杂，要对css,js不同类型的模块针对性不同配置

	2. vite核心是基于esm的开发服务器，浏览器请求资源，对应发送资源，启动快，

    Webpack 的热更新基于文件监听和模块依赖图，适合需要兼容性和复杂构建逻辑的项目，
            但随着项目规模增大，更新速度会变慢。
    Vite 的热更新基于 ESM 和浏览器原生模块系统，更新速度极快，适合现代浏览器环境的大型项目。

    生产环境中，Vite 使用 Rollup 进行打包。Rollup 同样支持将 CommonJS 模块转换为 ESM。
    开发环境：使用 ESBuild 动态将 CommonJS 模块转换为 ESM。
    生产环境：使用 Rollup 和 @rollup/plugin-commonjs 插件打包 CommonJS 模块。
    生产构建会进行预构建，就是将非esm转为esm
	  esm浏览器原生支持：通过 <script type="module"> 加载。

    esbuild 快得惊人，并且已经是一个在构建库方面比较出色的工具，
    但一些针对构建应用的重要功能仍然还在持续开发中 —— 特别是代码分割和 CSS 处理方面

    所以生产环境用Rollup 在应用打包方面更加成熟和灵活

    

六、Vue 3 的 Treeshaking

启用 Tree Shaking

// vite.config.js
export default {
  optimizeDeps: {
    include: ['vue'], // 确保 Vue 核心库被预优化
    exclude: ['unused-package'], // 排除未使用的依赖
  },
};

若通过 import * as 导入整个模块，Tree Shaking 无法识别具体使用了哪些内容。
​解决方案：始终按需导入（如 import { func } from 'module'）。

// webpack.config.js (Vue 3 项目)
module.exports = {
  configureWebpack: {
    output: {
      moduleFilename: 'esm.js', // 强制使用 ES6 Modules 格式
    },
    experiments: {
      outputModule: true, // Webpack 5+ 需要此配置
    },
  },
};

最佳实践：
使用 ES6 Modules 按需导入。
配合 TypeScript 获取更精准的静态分析。
利用动态导入（import()）实现代码分割。
通过构建工具（如 Vite/Webpack）启用 Tree Shaking。

七、 vue文件怎么解析： 
    https://www.cnblogs.com/heavenYJJ/p/18058142 ,
    https://blog.csdn.net/lph159/article/details/142413043
    https://zhuanlan.zhihu.com/p/535102297

    1. @vitejs/plugin-vue-jsx库中有个叫transform的钩子
    2. transform-> App.vue（底层调用vue/compiler-sfc） -> 创建descriptor 对象
    3. 对应的函数转js代码、render函数、import语句

    
    @vitejs/plugin-vue 就是一个 Rollup 插件
    Vue 文件的解析依赖于 @vue/compiler-sfc 包, 处理单文件组件（SFC）的编译器
    Vue 文件（单文件组件，Single File Component，SFC）

    (1)@vitejs/plugin-vue-jsx库中有个叫transform的钩子函数，每当vite加载模块的时候就会触发这个钩子函数。
    所以当import一个vue文件的时候，就会走到@vitejs/plugin-vue-jsx中的transform钩子函数中，
    在transform钩子函数中主要调用了transformMain函数。

    (2)genScriptCode函数为底层调用vue/compiler-sfc

    (3)调用genScriptCode函数传入第一步生成的descriptor对象     将<script setup>模块编译为浏览器可执行的js代码。
    调用genTemplateCode函数传入第一步生成的descriptor对象   将<template>模块编译为render函数。
    调用genStyleCode函数传入第一步生成的descriptor对象      将<style scoped>模块编译为类似这样的import语句

    (4)当浏览器执行到import "/src/App.vue?vue&type=style&index=0&scoped=7a7a37b1&lang.css";
    语句时，触发了加载模块操作，再次触发了@vitejs/plugin-vue-jsx中的transform钩子函数

八、babel : ES6/ES7的代码转化成指定浏览器能支持的代码

九、副作用  大致可以理解成：一个函数会、或者可能会对函数外部变量产生影响的行为
            eg:
            function go (url) {
            window.location.href = url
            }

            "sideEffects": [
            "./src/some-module.js"
            ]

            "sideEffects": false , 都没有副作用，可以树摇

    Dead Code ：未使用的导出、未引用的代码、副作用无关的代码
        // eg: data.js
        const data = [1, 2, 3];

        export function getData() {
            return data;
        }

        const result = data.reduce((acc, val) => acc + val, 0);
        console.log(result);

        虽然 reduce 函数被调用了，并且计算出了一个结果，但这个结果并没有被导出或者在其他地方使用。
        因此，这段代码对程序的行为没有任何影响（即没有副作用）

        https://juejin.cn/post/7276696853893546036


十、1、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。

    2、CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

    3、CommonJs 是单个值导出，ES6 Module可以导出多个

    4、CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层

    5、CommonJs 的 this 是当前模块，ES6 Module的 this 是 undefined


    ES Module ： 
    1. 编译时加载：esm 是编译时加载，也就是只有所有import的模块都递归加载完成，才会开始执行
    2. 确定的导入导出
    3. 无副作用的模块导入

    ESM 下模块之间的依赖关系是高度确定的，与运行状态无关，编译工具只需要对 ESM 模块做静态分析

    ES6 Modules 不支持循环引用（编译时报错）​

十一、
TerserWebpackPlugin，还有其他一些替代方案可以用来压缩和最小化 JavaScript 代码，
例如 UglifyJSWebpackPlugin 和 CleanCSSWebpackPlugin

webpack-obfuscator

https://blog.csdn.net/a123456234/article/details/141036779



十二、babel-runtime 是一个包含 babel 模块化运行时助手的库。
babel-runtime 的主要作用就是
    将这些可能被重用的代码抽取成单独的模块，以避免在每个文件中重复出现相同的代码。
它通过模块导入的方式引入这些功能，从而避免了对全局作用域的修改或污染

使用 babel-runtime 通常需要配合 babel-plugin-transform-runtime 插件一起使用

十三、Vite Server 的请求处理能力，是通过中间件实现的
https://zhuanlan.zhihu.com/p/532451109

Vite 的热更新相关脚本：/@vite/client
index.ts 的代码已经被编译成 js 了，并且拼接上了 sourcemap。
很多请求是 ts、tsx、vue，但无论什么后缀都是没有关系的，它们的 
Content-Type 都是 application/javascript，因此浏览器能够正确的运行处理。

热更新：
修改代码，vite server 监听到代码被修改
vite 计算出热更新的边界（即受到影响，需要进行更新的模块）
vite server 通过 websocket 告诉 vite client 需要进行热更新
浏览器拉取修改后的模块
执行热更新的代码


十四、diff算法：https://segmentfault.com/a/1190000023060173#item-3
flagment出现就是用看起来像一个普通的DOM元素，但它是虚拟的

为什么要得到最长稳定序列

因为我们需要一个序列作为基础的参照序列，其他未在稳定序列的节点，进行移动。

总结
经过上述我们大致知道了diff算法的流程
1 从头对比找到有相同的节点 patch ，发现不同，立即跳出。

2如果第一步没有patch完，立即，从后往前开始patch ,如果发现不同立即跳出循环。

3如果新的节点大于老的节点数 ，对于剩下的节点全部以新的vnode处理（ 这种情况说明已经patch完相同的vnode ）。

4 对于老的节点大于新的节点的情况 ， 对于超出的节点全部卸载 （ 这种情况说明已经patch完相同的vnode ）。

5不确定的元素（ 这种情况说明没有patch完相同的vnode ） 与 3 ，4对立关系。

补充：
有key值和没有key值的状况，头尾对比后，看长度去决定删除或者新增，
通过key值去判断哪些是可以复用的，根据最长稳定序列去移动或新建节点

十五、

style-loader: 将css添加到DOM的内联样式标签style里
css-loader :允许将css文件通过require的方式引入，并返回css代码
less-loader: 处理less
sass-loader: 处理sass
postcss-loader: 用postcss来处理CSS
autoprefixer-loader: 处理CSS3属性前缀，已被弃用，建议直接使用postcss
file-loader: 分发文件到output目录并返回相对路径
url-loader: 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url
html-minify-loader: 压缩HTML
babel-loader :用babel来转换ES6文件到ES

https://blog.csdn.net/weixin_44869002/article/details/105831784
sourse map 可以知道文件位置
css.sourceMap时，我们最好关闭css.extract

十六、https://vue3js.cn/interview/webpack/improve_build.html#%E4%BA%8C%E3%80%81%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96
优化 loader 配置
合理使用 resolve.extensions
优化 resolve.modules //
优化 resolve.alias
使用 DLLPlugin 插件 //
使用 cache-loader 
terser 启动多线程
合理使用 sourceMap

优化搜索时间、缩小文件搜索范围、减少不必要的编译等方面

resolve.extensions是解析到文件时自动添加拓展名 ： extensions:[".warm",".mjs",".js",".json"]

十七、Lodash
    思路 1：使用 Lodash-ES 替代 Lodash
    lodash-es 是 lodash 的 es modules 版本 ，是着具备 ES6 模块化的版本，体积小
    如果是使用webpack来进行打包的话, 
    我们在使用lodash库时, 尽量通过lodash-es来进行导入操作,可以减轻最终生产环境的代码量

    思路 2： 使用 babel-plugin-lodash
    插件 babel-plugin-lodash 和 lodash-webpack-plugin 能够在打包时去掉不必要的 lodash 代码，减小产物体积。

    为了在不修改现有代码的情况下实现按需加载，可以使用 babel-plugin-lodash 插件。
    该插件的原理是将 import _ from 'lodash' 转换为按需引入的方式，
    例如 import { deepClone } from 'lodash/deepClone'


    在 Vite 的配置文件中（通常是 vite.config.js），你需要集成 Babel 插件。
    import { defineConfig } from 'vite';
    import vue from '@vitejs/plugin-vue';
    import babel from '@rollup/plugin-babel';

    export default defineConfig({
      plugins: [
        vue(),
        babel({
          babelHelpers: 'bundled',
          presets: ['@babel/preset-env'],
          plugins: ['babel-plugin-lodash'],
          extensions: ['.js', '.jsx', '.ts', '.tsx', '.vue'],
          exclude: 'node_modules/**', // 排除 node_modules 目录下的文件
        }),
      ],
    });

    babelHelpers: 'bundled' 是指定 Babel 如何处理辅助函数的选项。bundled 选项告诉 Babel 将辅助函数包含在捆绑包中。
    presets: ['@babel/preset-env'] 是 Babel 的预设配置，帮助处理 ES6+ 语法。

    在开发阶段保留原始的引入方式，避免构建速度下降。
    在生产环境中，通过 Babel 插件进行按需加载，以减小最终打包的体积。

    链接：https://juejin.cn/post/7439324075116642355


    在整个优化过程中，我们总结了以下几点经验：

    逐步替换，分阶段实施：面对大规模的代码替换，不要一蹴而就，而是分阶段实施，并在每个阶段进行详细测试。
    自动化测试的重要性：在大规模代码变更后，自动化测试能帮助我们快速验证功能的正确性，避免因手动测试不彻底而导致的上线问题。
    工具链的理解与合理使用：深刻理解工具（如 Babel）的工作原理，有助于我们在做技术选型时做出更加合适的决定。


十八、vite依赖预构建：
预构建：  https://blog.csdn.net/xiaolinlife/article/details/138524415

    （1）1. 非esm 转为esm , 2. 合并模块
    Vite 中正是为了「模块兼容性」以及「性能」这两方面大的原因，所以需要进行依赖预构建

    将非 ESM 规范的代码转换为符合 ESM 规范的代码；
    将第三方依赖内部的多个文件合并为一个，减少 http 请求数量；

    （2）Vite 将会使用 esbuild 在应用启动时对于依赖部分进行预构建依赖。
    依赖预构建仅适用于开发模式，并使用 esbuild 将依赖项转换为 ES 模块。
    在生产构建中，将使用 @rollup/plugin-commonjs

    （3）比如 lodash-es 中存在超过 600 个内置模块，当我们执行 import { debounce } from ‘lodash’ 时，
    如果不进行预构建浏览器会同时发出 600 多个 HTTP 请求，这无疑会让页面加载变得明显缓慢。
    正式通过依赖预构建，将 lodash-es 预构建成为单个模块后仅需要一个 HTTP 请求就可以解决上述的问题

    （4）借助预构建的过程将这部分非 esm 模块的依赖模块转化为 esm 模块

     vite 在预编译时会对于项目中使用到的第三方依赖进行依赖预构建，
     将构建后的产物存放在 node_modules/.vite/deps 目录中，比如 ahooks.js、react.js 等
     依赖预构建的过程简单来说就是生成 node_modules/deps 文件即可。

     「将构建后的产物存储在 .vite/deps 目录中，同时将映射关系保存在 .vite/deps/_metadata.json 中，
      其中 optimized 对象中的 react 表示原始依赖的入口文件而 file 则表示经过预构建后生成的产物（两者皆为相对路径）。」

十九、
依赖扫描：https://juejin.cn/post/7129160452377935903?spm=a2c6h.12873639.article-detail.9.22f9780anx17VW#heading-2
  只有 bare import（裸依赖）会执行依赖预构建，
  如：import xxx from "vue/xxx"   ，这个不行： import xxx from "./foo.ts" 
  用名称去访问的模块是裸模块
  用路径去访问的模块，不是 bare import

  深度遍历依赖树，并对各种类型的模块进行处理

  最复杂的就是 html 类型模块的处理，需要使用虚拟模块；
  当遇到 bare import 时，需要判断是否在 node_modules 中，在的才记录依赖，然后  external。
  其他 JS 无关的模块就直接 external
  JS 模块由于 esbuild 本身能处理，不需要做任何的特殊操作

  预构建只针对js

二十、
  vite插件：
  小图片: 对于较小的图片，@rollup/plugin-image直接将其转换为 Base64 编码
        并嵌入到 JavaScript 文件中可以减少 HTTP 请求，提升页面加载速度。
  大图片: 对于较大的图片，建议使用 @rollup/plugin-url 插件，
        将图片文件输出到指定目录，并在代码中引用其路径。

二十一、计算时间
  time npm run build


  npm run build  55.54s user 4.55s system 269% cpu 22.260 total


  dist/svg/logo-0224cdff.svg                                      266.39 KiB
dist/svg/banner-title-1e4eb353.svg                              5.61 KiB
dist/svg/banner-bg-ff7da76c.svg                                 291.91 KiB
dist/svg/footer-logo1-fdb8666d.svg                              6.14 KiB