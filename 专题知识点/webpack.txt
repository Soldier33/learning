[webpack] 如何优化产物大小 https://github.com/pro-collection/interview-question/issues/887

  A、 功能
  1. 使用 Tree Shaking   清除未引用代码
  2. 启用压缩(Uglification)  如删除未使用的代码、缩短变量名等
  3. 代码分割(Code Splitting)   可以把代码分成多个 bundle，然后按需加载，从而减少初始加载时间
  4. 使用 Externals 减轻体积
  5. 利用缓存(Caching)  [contenthash] 替换 [hash] 或 [chunkhash] 来为输出文件命名，只有当文件内容改变时，文件名称才改变
  6. 移除未使用的 CSS 自动去除未使用的 CSS
  7. 优化图片   image-webpack-loader等图片压缩插件，可以减小图片文件的体积


   https://vue3js.cn/interview/webpack/improve_build.html#%E4%BA%8C%E3%80%81%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96
    优化 loader 配置
    合理使用 resolve.extensions
    优化 resolve.modules //
    优化 resolve.alias
    使用 DLLPlugin 插件 //
    使用 cache-loader 
    terser 启动多线程
    合理使用 sourceMap

    优化搜索时间、缩小文件搜索范围、减少不必要的编译等方面

      别名配置
      压缩代码、打包时去除打印信息
      优化打包chunk-vendors.js， splitChunks： minSize: 20000, // 依赖包超过20000bit将被单独打包
      生产环境的 source map，可以将其设置为 false 以加速生产环境构建，默认值是true
      sourceMap: false,   //关掉sourcemap 会生成对于调试的完整的.map文件，但同时也会减慢打包速度
      parallel: true, //使用多进程并行运行来提高构建速度。默认并发运行数：os.cpus().length - 1。
      开启gizp压缩： compression webpack plugin
      图片压缩【image-webpack-loader】使用

    resolve.extensions是解析到文件时自动添加拓展名 ： extensions:[".warm",".mjs",".js",".json"]
  好文：https://www.cnblogs.com/ypSharing/p/vue-webpack.html

二、webpack 中有三种生成哈希值规则的方式，可以用来区分文件是否修改。
  * hash 与整个项目有关，项目里有文件修改，所有文件的哈希值都会变化。
  * chunkhash 与入口有关，同一入口的文件被视为一个整体，当其中一个文件修改时，同入口的所有文件哈希值发生改变。
  * contenthash 只与文件内容有关，文件内容发生改变，才会更改该文件的哈希值

  文件指纹
    A、
    1. hash没有缓存
    2. chunkhash ： 有缓存但是如果修改css， 也会重新打包
    若对应css改变，则构建出来的bundle文件的的chunkhash也会随之改变，但入口文件xx.js的内容并没有改变，所以没有完全达到缓存意义。

    3. contenthash ：更优的缓存

    B、给css也加contenthash
    plugins: [
        new MiniCssExtractPlugin({
            filename: '[name].[contenthash].css',
        }),
    ],


    C、
    通过file-loader或url-loader来处理图片，这时设置图片的hash，需要注意的是[hash]表示的是根据文件内容生成hash

三、Loader 和 Plugin 的区别
					            Loader						Plugin
    典型应用	处理 CSS、图片、字体等资源	  代码压缩、资源管理、环境变量注入等
    配置方式	在 module.rules 中配置	     在 plugins 中配置
    作用	    转换模块的源代码			  扩展 Webpack 的功能
    输入/输出	接收源文件，返回转换后的内容   不直接处理文件，而是操作构建过程
    Loader：用于转换模块的源代码。适合处理文件级别的任务（如 CSS、图片、字体等）。通过 module.rules 配置。
    Plugin：用于扩展 Webpack 的功能。适合处理构建过程级别的任务（如代码压缩、资源优化等）。通过 plugins 配置。


    style-loader: 将css添加到DOM的内联样式标签style里
    css-loader :允许将css文件通过require的方式引入，并返回css代码
    less-loader: 处理less
    sass-loader: 处理sass
    postcss-loader: 用postcss来处理CSS
    autoprefixer-loader: 处理CSS3属性前缀，已被弃用，建议直接使用postcss
    file-loader: 分发文件到output目录并返回相对路径
    url-loader: 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url
    html-minify-loader: 压缩HTML
    babel-loader :用babel来转换ES6文件到ES

    https://blog.csdn.net/weixin_44869002/article/details/105831784
    sourse map 可以知道文件位置
    css.sourceMap时，我们最好关闭css.extract


    Lodash
    思路 1：使用 Lodash-ES 替代 Lodash
    lodash-es 是 lodash 的 es modules 版本 ，是着具备 ES6 模块化的版本，体积小
    如果是使用webpack来进行打包的话, 
    我们在使用lodash库时, 尽量通过lodash-es来进行导入操作,可以减轻最终生产环境的代码量

    思路 2： 使用 babel-plugin-lodash
    插件 babel-plugin-lodash 和 lodash-webpack-plugin 能够在打包时去掉不必要的 lodash 代码，减小产物体积。

    为了在不修改现有代码的情况下实现按需加载，可以使用 babel-plugin-lodash 插件。
    该插件的原理是将 import _ from 'lodash' 转换为按需引入的方式，
    例如 import { deepClone } from 'lodash/deepClone'


    在 Vite 的配置文件中（通常是 vite.config.js），你需要集成 Babel 插件。
    import { defineConfig } from 'vite';
    import vue from '@vitejs/plugin-vue';
    import babel from '@rollup/plugin-babel';

    export default defineConfig({
      plugins: [
        vue(),
        babel({
          babelHelpers: 'bundled',
          presets: ['@babel/preset-env'],
          plugins: ['babel-plugin-lodash'],
          extensions: ['.js', '.jsx', '.ts', '.tsx', '.vue'],
          exclude: 'node_modules/**', // 排除 node_modules 目录下的文件
        }),
      ],
    });

    babelHelpers: 'bundled' 是指定 Babel 如何处理辅助函数的选项。bundled 选项告诉 Babel 将辅助函数包含在捆绑包中。
    presets: ['@babel/preset-env'] 是 Babel 的预设配置，帮助处理 ES6+ 语法。

    在开发阶段保留原始的引入方式，避免构建速度下降。
    在生产环境中，通过 Babel 插件进行按需加载，以减小最终打包的体积。

    链接：https://juejin.cn/post/7439324075116642355


    在整个优化过程中，我们总结了以下几点经验：

    逐步替换，分阶段实施：面对大规模的代码替换，不要一蹴而就，而是分阶段实施，并在每个阶段进行详细测试。
    自动化测试的重要性：在大规模代码变更后，自动化测试能帮助我们快速验证功能的正确性，避免因手动测试不彻底而导致的上线问题。
    工具链的理解与合理使用：深刻理解工具（如 Babel）的工作原理，有助于我们在做技术选型时做出更加合适的决定。



四、替换字符串
    方案	适用场景	配置复杂度	性能影响	插件依赖
    DefinePlugin	简单宏替换	★★☆	★★	无
    ReplacePlugin	复杂模式匹配	★★★	★★	✔️
    (replace-webpack-plugin)
    (string-replace-webpack-plugin)
    HtmlWebpackPlugin	HTML 文件占位符替换	★★☆	★★	✔️
    Environment Variables	环境变量注入	★★☆	★★	✔️（dotenv）
    Custom Loader	特定文件深度处理	★★★★	★★★	✔️

五、Webpack 和 vite 的原理  (热更新就是更新受影响的模块，但是不刷新页面)
	1. Webpack 核心是项目整体打包，将多个文件打包成一个，首次加载时间过长，bundle文件
	webpack热更新复杂，要对css,js不同类型的模块针对性不同配置

	2. vite核心是基于esm的开发服务器，浏览器请求资源，对应发送资源，启动快，

    Webpack 的热更新基于文件监听和模块依赖图，适合需要兼容性和复杂构建逻辑的项目，
            但随着项目规模增大，更新速度会变慢。
    Vite 的热更新基于 ESM 和浏览器原生模块系统，更新速度极快，适合现代浏览器环境的大型项目。

    生产环境中，Vite 使用 Rollup 进行打包。Rollup 同样支持将 CommonJS 模块转换为 ESM。
    开发环境：使用 ESBuild 动态将 CommonJS 模块转换为 ESM。
    生产环境：使用 Rollup 和 @rollup/plugin-commonjs 插件打包 CommonJS 模块。
    生产构建会进行预构建，就是将非esm转为esm
	  esm浏览器原生支持：通过 <script type="module"> 加载。

    esbuild 快得惊人，并且已经是一个在构建库方面比较出色的工具，
    但一些针对构建应用的重要功能仍然还在持续开发中 —— 特别是代码分割和 CSS 处理方面

    所以生产环境用Rollup 在应用打包方面更加成熟和灵活

    

六、Vue 3 的 Treeshaking

    未使用的导出、未引用的代码、副作用无关的代码

    启用 Tree Shaking
    // vite.config.js
    export default {
      optimizeDeps: {
        include: ['vue'], // 确保 Vue 核心库被预优化
        exclude: ['unused-package'], // 排除未使用的依赖
      },
    };

    若通过 import * as 导入整个模块，Tree Shaking 无法识别具体使用了哪些内容。
    ​解决方案：始终按需导入（如 import { func } from 'module'）。

    // webpack.config.js (Vue 3 项目)
    module.exports = {
      configureWebpack: {
        output: {
          moduleFilename: 'esm.js', // 强制使用 ES6 Modules 格式
        },
        experiments: {
          outputModule: true, // Webpack 5+ 需要此配置
        },
      },
    };

    最佳实践：
    使用 ES6 Modules 按需导入。
    配合 TypeScript 获取更精准的静态分析。
    利用动态导入（import()）实现代码分割。
    通过构建工具（如 Vite/Webpack）启用 Tree Shaking。

    副作用  大致可以理解成：一个函数会、或者可能会对函数外部变量产生影响的行为
        eg:
          function go (url) {
          window.location.href = url
          }

          "sideEffects": [
          "./src/some-module.js"
          ]

        "sideEffects": false , 都没有副作用，可以树摇

    Dead Code ：未使用的导出、未引用的代码、副作用无关的代码
        // eg: data.js
        const data = [1, 2, 3];

        export function getData() {
            return data;
        }

        const result = data.reduce((acc, val) => acc + val, 0);
        console.log(result);

        虽然 reduce 函数被调用了，并且计算出了一个结果，但这个结果并没有被导出或者在其他地方使用。
        因此，这段代码对程序的行为没有任何影响（即没有副作用）

        https://juejin.cn/post/7276696853893546036

七、 

八、babel : ES6/ES7的代码转化成指定浏览器能支持的代码

九、


十、1、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。

    2、CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

    3、CommonJs 是单个值导出，ES6 Module可以导出多个

    4、CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层

    5、CommonJs 的 this 是当前模块，ES6 Module的 this 是 undefined


    ES Module ： 
    1. 编译时加载：esm 是编译时加载，也就是只有所有import的模块都递归加载完成，才会开始执行
    2. 确定的导入导出
    3. 无副作用的模块导入

    ESM 下模块之间的依赖关系是高度确定的，与运行状态无关，编译工具只需要对 ESM 模块做静态分析

    ES6 Modules 不支持循环引用（编译时报错）​

十一、




十二、babel-runtime 是一个包含 babel 模块化运行时助手的库。
    babel-runtime 的主要作用就是
        将这些可能被重用的代码抽取成单独的模块，以避免在每个文件中重复出现相同的代码。
        它通过模块导入的方式引入这些功能，从而避免了对全局作用域的修改或污染

    使用 babel-runtime 通常需要配合 babel-plugin-transform-runtime 插件一起使用

十三、Vite Server 的请求处理能力，是通过中间件实现的
    https://zhuanlan.zhihu.com/p/532451109

    Vite 的热更新相关脚本：/@vite/client
    index.ts 的代码已经被编译成 js 了，并且拼接上了 sourcemap。
    很多请求是 ts、tsx、vue，但无论什么后缀都是没有关系的，它们的 
    Content-Type 都是 application/javascript，因此浏览器能够正确的运行处理。

    热更新：
    修改代码，vite server 监听到代码被修改
    vite 计算出热更新的边界（即受到影响，需要进行更新的模块）
    vite server 通过 websocket 告诉 vite client 需要进行热更新
    浏览器拉取修改后的模块
    执行热更新的代码


十四、

十五、

十六、

十七、

十八、vite依赖预构建：
预构建：  https://blog.csdn.net/xiaolinlife/article/details/138524415

    （1）1. 非esm 转为esm , 2. 合并模块
    Vite 中正是为了「模块兼容性」以及「性能」这两方面大的原因，所以需要进行依赖预构建

    将非 ESM 规范的代码转换为符合 ESM 规范的代码；
    将第三方依赖内部的多个文件合并为一个，减少 http 请求数量；

    （2）Vite 将会使用 esbuild 在应用启动时对于依赖部分进行预构建依赖。
    依赖预构建仅适用于开发模式，并使用 esbuild 将依赖项转换为 ES 模块。
    在生产构建中，将使用 @rollup/plugin-commonjs

    （3）比如 lodash-es 中存在超过 600 个内置模块，当我们执行 import { debounce } from ‘lodash’ 时，
    如果不进行预构建浏览器会同时发出 600 多个 HTTP 请求，这无疑会让页面加载变得明显缓慢。
    正式通过依赖预构建，将 lodash-es 预构建成为单个模块后仅需要一个 HTTP 请求就可以解决上述的问题

    （4）借助预构建的过程将这部分非 esm 模块的依赖模块转化为 esm 模块

     vite 在预编译时会对于项目中使用到的第三方依赖进行依赖预构建，
     将构建后的产物存放在 node_modules/.vite/deps 目录中，比如 ahooks.js、react.js 等
     依赖预构建的过程简单来说就是生成 node_modules/deps 文件即可。

     「将构建后的产物存储在 .vite/deps 目录中，同时将映射关系保存在 .vite/deps/_metadata.json 中，
      其中 optimized 对象中的 react 表示原始依赖的入口文件而 file 则表示经过预构建后生成的产物（两者皆为相对路径）。」

十九、
依赖扫描：https://juejin.cn/post/7129160452377935903?spm=a2c6h.12873639.article-detail.9.22f9780anx17VW#heading-2
  只有 bare import（裸依赖）会执行依赖预构建，
  如：import xxx from "vue/xxx"   ，这个不行： import xxx from "./foo.ts" 
  用名称去访问的模块是裸模块
  用路径去访问的模块，不是 bare import

  深度遍历依赖树，并对各种类型的模块进行处理

  最复杂的就是 html 类型模块的处理，需要使用虚拟模块；
  当遇到 bare import 时，需要判断是否在 node_modules 中，在的才记录依赖，然后  external。
  其他 JS 无关的模块就直接 external
  JS 模块由于 esbuild 本身能处理，不需要做任何的特殊操作

  预构建只针对js

二十、
  vite插件：
  小图片: 对于较小的图片，@rollup/plugin-image直接将其转换为 Base64 编码
        并嵌入到 JavaScript 文件中可以减少 HTTP 请求，提升页面加载速度。
  大图片: 对于较大的图片，建议使用 @rollup/plugin-url 插件，
        将图片文件输出到指定目录，并在代码中引用其路径。

二十一、计算时间
  time npm run build


  npm run build  55.54s user 4.55s system 269% cpu 22.260 total


二十二、  
  webpack开箱即用只支持JS和JSON两种文件类型，需要loader将其他类型的文件转为webpack能够处理的文件类型，并添加到依赖图中完成打包。

  loader 本身是一个函数

  Plugins: https://juejin.cn/post/6910175031238606861
  插件就是一个含有apply方法的类，在apply方法中会传入compiler（即webpack实例）。
  我们可以通过调用compiler中暴露的钩子函数，完成在webpack构造过程的相关功能。

  class MyExampleWebpackPlugin {
    apply(compiler) {
      compiler.hooks.emit.tapAsync(
        'MyExampleWebpackPlugin',
        (compilation, callback) => {
          ...
          callback();
        }
      );
    }
  }

  Webpack配置文件中，通过entry设置编译入口文件，在output设置编译后的文件目录，通过loader引入其他类型文件，通过plugin来实现一些loader无法达到的功能。


  filename：对应于entry里面生成出来的文件名。
  chunkFilename：chunkFilename就是未被列在entry中，但有些场景需要被打包出来的文件命名配置。比如按需加载（异步）模块的时候。

。
二十三、Chunk: https://juejin.cn/post/6844903889393680392
  Webpack的打包是从一个入口文件开始，也可以说是入口模块，入口模块引用这其他模块，模块再引用模块。
  Webpack通过引用关系逐个打包模块，这些module就形成了一个Chunk。

  Chunk是过程中的代码块，Bundle是结果的代码块。

  产生Chunk的三种途径
  entry入口
  异步加载模块
  代码分割（code spliting）

二十四、webpack插件

  TerserWebpackPlugin，还有其他一些替代方案可以用来压缩和最小化 JavaScript 代码，
  例如 UglifyJSWebpackPlugin 和 CleanCSSWebpackPlugin

  webpack-obfuscator

  https://blog.csdn.net/a123456234/article/details/141036779

  1. uglifyjs-webpack-plugin
    压缩 JavaScript 代码的 Webpack 插件
    配置选项说明：
    test: 匹配需要压缩的文件。
    exclude: 排除不需要压缩的文件或目录。
    cache: 是否启用缓存，提高构建速度。
    parallel: 是否启用并行压缩，提高压缩效率。
    sourceMap: 是否生成 source map 文件。
    uglifyOptions: UglifyJS 的具体配置选项，如压缩选项、输出选项等。

    打包时去除打印信息



  2. 经过SideEffectsFlagPlugin处理后，没有副作用且没有被使用的模块都会被打上sideEffectFree标记

  // webpack.pord.config.js
  module.exports = {
    optimization: {
      sideEffects: true
    }
  };


  3. terser-webpack-plugin来进行压缩

  // webpack.pord.config.js
  module.exports = {
      optimization: {
          minimize: true
      }
  }

  // js压缩
  const TerserPlugin = require('terser-webpack-plugin');
  module.exports = {
      optimization: {
          minimizer: [
              new TerserPlugin({
                  cache: true,
                  parallel: true,
                  sourceMap: true, // Must be set to true if using source-maps in production
                  terserOptions: {
                    // https://github.com/webpack-contrib/terser-webpack-plugin#terseroptions
                  }
              }),
          ]
      }
  }

  4. 开启gizp压缩
  const CompressionWebpackPlugin = require('compression-webpack-plugin')//gzip压缩

    new CompressionWebpackPlugin({
        filename: '[path].gz[query]',
        algorithm: 'gzip',
        test: new RegExp('\\.(' + productionGzipExtensions.join('|') + ')$'),
        threshold: 10240,
        minRatio: 0.8,
    })

  5、 图片压缩【image-webpack-loader】使用

  二十五、
    // 别名配置
    Object.assign(config, {
        // 开发生产共同配置
        resolve: {
            alias: {
            '@': path.resolve(__dirname, './src'),
            '@c': path.resolve(__dirname, './src/components'),
            '@p': path.resolve(__dirname, './src/pages')
            }
        }
    }),

    config.output.filename = `[name].${Version}.${Timestamp}.js`  //打包生成的文件
    config.output.chunkFilename = `[name].${Version}.${Timestamp}.js`


    //兼容性

    // lib-flexible
      postcss: {
          plugins: [
              //remUnit这个配置项的数值是多少呢？？？ 通常我们是根据设计图来定这个值，原因很简单，便于开发。
              //假如设计图给的宽度是750，我们通常就会把remUnit设置为75，这样我们写样式时，可以直接按照设计图标注的宽高来1:1还原开发。
              require('postcss-px2rem')({
                  remUnit: 37.5
              })
          ]
      }