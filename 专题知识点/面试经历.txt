一、
注重缓存，前端缓存，webpack缓存，浏览器缓存

二、idea
Vue文件，三个部份，构建
jq链式原理
webpack 替换，手写loader, plugin
Treeshaking
diff细节：最长子序列

三、
业务或者技术上专研，
Canvas 大数据量加载， antV
V-model如何用, 
设计模式
nextTick原理
性能优化
业务代码

四、
表单、表格、缓存策略
Css后处理 为什么用vh
图片能不能gzip
review关于前端
首屏从什么结果优化到什么结果
external: ['vue'], 还能不能tree shaking 
webpack和vite 对比



Css后处理 为什么用vh？
1. 视口比例控制的精准性
场景：需要元素尺寸严格按视口比例缩放（如全屏轮播图、背景遮罩）
    示例：实现一个始终占屏幕高度 60% 的容器：
        css
        Copy
        .container {
        height: 60vh; /* 直接挂钩视口高度 */
        }
对比 rem：需通过 JS 动态计算 1rem 对应的视口比例，复杂度高

2. 字体响应式的终极方案
场景：希望字体大小随视口平滑缩放（非断点式变化）

示例：字体从 PC 到移动端无缝缩小：

优势：无需媒体查询断点，减少代码维护成本
3. 避开 rem 的字体缩放污染
* 问题：用户修改浏览器默认字体大小时，rem 布局可能被破坏
* 示例：用户将浏览器默认字体从 16px 改为 20px 时：
    * rem 布局元素会按比例放大，可能导致 UI 错乱
    * vw/vh 布局完全不受影响

        webpack和vite 对比：
        1. bundle， 只有业务代码bundle
        2. loader, plugin
        3. 持久化缓存， vite也有缓存策略
        4. treeshaking 
        5. 分包： vendor, components-util
        6. 热更新
        7. 代码分割、压缩文件：减少请求，较少体积    体积大小、共用率、更新频率
        8. sourceMap
        9. AST利用
        webpack : 持久化缓存、 sourceMap 丰富、 模块依赖关系图
        vite：  prefetch、预热常用文件、 vite依赖预构建、依赖扫描，
                esbuild + rollup 、 按需加载、缓存策略

                1. 首屏、懒加载响应速度对比 Webpack 会慢；二次预构建会对开发体验造成影响；
                2. vite  build.sourcemap¶
                类型： boolean | 'inline' | 'hidden'
                默认： false

        转换过程是通过 loader 处理(不同的构建工具，叫法不同。
        Webpack、Esbuild 是 loader， Rollup、Parcel、Vite 是 plugin)。

        VITE v3.2.7  ready in 921 ms 

        加载时间：2.10 秒

五、
怎么收集依赖
react和vue的差异
node相关， 脚手架
非关系型数据库
SSR理解




六、
display 有哪些
none inline block inline-block


h1   p  div   ul


i
img
span
input
a





<style>
    .my-box {
        width: 100px;
        height: 100px;
        padding: 10px;
        border: 1px solid blue;
        background-color: red;
    }
</style>

<div class="my-box"></div>

讲一下这两个
1. 
<style>
    .outer {
        display: flex;
        width: 180px;
        height: 180px
    }
</style>
<div class="outer">
    <div style="background: blue">1</div>
    <div style="background: red">2</div>
    <div style="background: blue">3</div>
    <span style="background: red">4</span>
    <span style="background: blue">5</span>
    <span style="background: red">6</span>
</div>

2. 
<style>
    .outer {
        display: flex;
        width: 180px;
        height: 180px
        align-item: center;
        
        background-color: red;
    }

    .inner {
        flex: none;
        width: 80px;
        width: 80px;
        background-color: blue;
    }
</style>
<div class="outer">
    <div class="inner">1</div>
</div>


align-items
align-content

align-items 关注的是单个项目在交叉轴上的对齐，而 align-content 关注的是多行项目整体在交叉轴上的对齐和空间分布。



http://www.xyz.com/
https://www.xyz.com/
http://www.abc.com:1234/api/xxx
http://www.abc.com:5678/a.html
http://www.abc.com:5678/b/



https://www.abc.com/api/xxx (method:GET)
https://www.xyz.com/a.html

jsonp是什么

function abc() {
    console.log(myName);
}
function xyz() {
    var myName = "渣渣前端";
    abc();
}
var myName = "辣鸡后端";
xyz();


//辣鸡后端
在 JavaScript 中，
函数内部的局部变量只能在该函数内部访问，
不会影响全局作用域中的同名变量。


unction printName(){
    var surName = 'zhao';
    //通过闭包获取'zhao'
    function addFirstName(){
        console.log('jack ' + surName);
    }
    addFirstName(surName);
}

var surName = 'wu';
printName();

输出: jack zhao



function abc() {
    console.log(myName);
}
function xyz() {
    var myName = "渣渣前端";
    abc();
}
var myName = "辣鸡后端";
xyz();

输出:  辣鸡后端


绘制 有哪些可讲的：
https://www.bilibili.com/video/BV1Xy4y1f7gv?vd_source=cd65804c3893d64a7ee909de29c50ddf&spm_id_from=333.788.videopod.episodes&p=3

display 有哪些

绘制 有哪些可讲的

跨域有哪些，nginx具体怎么配置，jsonp 怎么写


align-items、 align-content区别是什么

八、拖拽原理
输入：最长连续无重复字符串

输出：'aabcda121' → 'bcda12'


function lengthOfLongestSubstring(s) {
    let charSet = new Set();
    let left = 0, right = 0, maxLength = 0;
    
    while (right < s.length) {
        if (!charSet.has(s[right])) {
            charSet.add(s[right]);
            maxLength = Math.max(maxLength, right - left + 1);
            right++;
        } else {
            charSet.delete(s[left]);
            left++;
        }
    }
    return maxLength;
}


//哈希集合与滑动窗口
let charSet = new Set();
let left = 0, right = 0, maxLength = 0;
while (right < s.length) {
    if (!charSet.has(s[right])) {
        charSet.add(s[right]);
        maxLength = Math.max(maxLength, right - left + 1);;
        right++;
    } else {
        charSet.delete(s[left]);
        left++;
    }
}
// 暴力
let max = 0;
for (let i = 0; i < s.length; i++) {
    let arr = [];
    for (let j = i; j < s.length; j++) {
        if (arr.indexOf(s[j]) == -1) {
            arr.push(s[j]);
        } else {
            break;
        }
        if (max < arr.length) {
            max = arr.length
        }
    }
}
return max;
