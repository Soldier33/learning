一、vue3 ：watch和watchEffect的区别
watch, 要指定监听的数据，可以知道变化前后的数据
watchEffect ，不需要指定，自动依赖收集，仅提供新值，简化配置
https://juejin.cn/post/7474062103994646582

二、vue3的dom树为什么快，渲染机制，带编译时信息的虚拟dom
1. 缓存静态内容，没有变量的节点就不做对比，直接缓存
2. 更新类型标记，vnode创建时编码了每个元素需要更新的类型 (补丁patch算法优化)
3. 树结构打平，被打标记的节点被存在数组里面

静态提升、补丁算法优化、事件处理优化:静态事件提升、事件缓存（将这个事件监听器提取出来 复用）

静态节点和属性提升：减少重复创建和比对。
补丁标志：精准更新动态节点。
块树优化：缩小比对范围。
事件侦听器缓存：减少事件处理开销。
Tree Shaking 支持：减少打包体积。

三、[Vue3] reactive() 的局限性
1. 基础数据不能响应式、 
2. 不能替换整个对象  // 这样做是错误的，不会保持响应性 state = { count: 1 };
3. 解构操作不友好
// 直接解构将会失去响应性
const { count, title } = state;

// 使用 toRefs 解构，保持响应性
const { count, title } = toRefs(state);


四、pinia 和 vuex
pinia 简洁和直观的 API , state, action, 灵活和易于使用。可以轻松地将 store 拆分为多个模块,action 能使用异步操作
Vuex 的语法相对较为复杂，需要定义state mutations、actions 和 getters 

五、vue中 keep-alive底层是如何实现的？

    <keep-alive> 的主要功能是缓存不活动的组件实例，而不是销毁它们。当组件再次被激活时，直接从缓存中恢复，避免重新渲染和挂载。

    缓存机制:
    <keep-alive> 内部维护了一个缓存对象（cache），用于存储被缓存的组件实例。
    缓存对象的键是组件的 name 选项或组件的 tag，值是组件的 VNode（虚拟 DOM 节点）。