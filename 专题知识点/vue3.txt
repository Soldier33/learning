1、vue3 ：watch和watchEffect的区别
    watch, 要指定监听的数据，可以知道变化前后的数据
    watchEffect ，不需要指定，自动依赖收集，仅提供新值，简化配置
    https://juejin.cn/post/7474062103994646582

2、vue3的dom树为什么快，渲染机制，带编译时信息的虚拟dom
    1. 缓存静态内容，没有变量的节点就不做对比，直接缓存
    2. 更新类型标记，vnode创建时编码了每个元素需要更新的类型 (补丁patch算法优化)
    3. 树结构打平，被打标记的节点被存在数组里面

    静态提升、补丁算法优化、事件处理优化:静态事件提升、事件缓存（将这个事件监听器提取出来 复用）

    静态节点和属性提升：减少重复创建和比对。
    补丁标志：精准更新动态节点。
    块树优化：缩小比对范围。
    事件侦听器缓存：减少事件处理开销。
    Tree Shaking 支持：减少打包体积。

3、[Vue3] reactive() 的局限性
    1. 基础数据不能响应式、 
    2. 不能替换整个对象  // 这样做是错误的，不会保持响应性 state = { count: 1 };
    3. 解构操作不友好
    // 直接解构将会失去响应性
    const { count, title } = state;

    // 使用 toRefs 解构，保持响应性
    const { count, title } = toRefs(state);


4、pinia 和 vuex
    pinia 简洁和直观的 API , state, action, 灵活和易于使用。可以轻松地将 store 拆分为多个模块,action 能使用异步操作
    Vuex 的语法相对较为复杂，需要定义state mutations、actions 和 getters 

5、vue中 keep-alive底层是如何实现的？

    <keep-alive> 的主要功能是缓存不活动的组件实例，而不是销毁它们。当组件再次被激活时，直接从缓存中恢复，避免重新渲染和挂载。

    缓存机制:
    <keep-alive> 内部维护了一个缓存对象（cache），用于存储被缓存的组件实例。
    缓存对象的键是组件的 name 选项或组件的 tag，值是组件的 VNode（虚拟 DOM 节点）。

6 、计算属性如何收集依赖： https://juejin.cn/post/6854573220046372872
    依赖收集的实现集中在 Watcher 与 Dep 两个类中

    Dep 简单对象 data , props
    Watcher 复合对象 computed, render

    Dep.prototype.depend -> 依赖对象记录到 Watcher 对象 

    Vue3中依赖收集过程的设计与Vue2相似，细节上有如下区别：

    核心接口变成了 Composition 风格的 track 与 trigger 函数。
    内部维护了一个 WeakMap 对象，用于记录属性到 effect 对象的依赖关系

7、diff算法：https://segmentfault.com/a/1190000023060173#item-3
    flagment出现就是用看起来像一个普通的DOM元素，但它是虚拟的

    为什么要得到最长稳定序列

    因为我们需要一个序列作为基础的参照序列，其他未在稳定序列的节点，进行移动。

    总结
    经过上述我们大致知道了diff算法的流程
    1 从头对比找到有相同的节点 patch ，发现不同，立即跳出。

    2如果第一步没有patch完，立即，从后往前开始patch ,如果发现不同立即跳出循环。

    3如果新的节点大于老的节点数 ，对于剩下的节点全部以新的vnode处理（ 这种情况说明已经patch完相同的vnode ）。

    4 对于老的节点大于新的节点的情况 ， 对于超出的节点全部卸载 （ 这种情况说明已经patch完相同的vnode ）。

    5不确定的元素（ 这种情况说明没有patch完相同的vnode ） 与 3 ，4对立关系。

    补充：
    有key值和没有key值的状况，头尾对比后，看长度去决定删除或者新增，
    通过key值去判断哪些是可以复用的，根据最长稳定序列去移动或新建节点

    vue2的diff算法，只要依赖key, 没有key就首尾对比
    收集旧树中key相同的节点，复用在新树

8、Vue中的$nextTick有什么作用
Vue 的响应式系统是异步的。
当数据发生变化时，Vue 并不会立即更新 DOM，而是将更新操作推入一个队列，并在下一个事件循环中批量处理。
意味着，如果在数据变化后立即访问 DOM，可能会获取到未更新的 DOM 状态。
$nextTick 提供了一种机制，确保在 DOM 更新完成后再执行代码。


9. 