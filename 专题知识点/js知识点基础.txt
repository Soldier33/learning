简单知识点：
1. 基础类型在栈中，引用类型在堆中
    
2. 前端内存泄漏：未清空的定时器、闭包、引用未被清除

3.  typeof 引用类型不行，   typeof XXX
    instanceof 基本数据类型不行  XXX instanceof Object

4. 改变原数组：pop, push, shift, unshift, sort, reverse, splice

5、WeakMap 和 WeakSet 通过弱引用避免内存泄漏

6、node中函数带有Sync 一般是同步函数

7、 生成器yield: 
      1. 重启生成器的执行：next(), send(参数), throw()
      2. 可迭代的迭代器，所以可以用for in

8. 密钥必须安全存储和传输，避免泄露

9. numStr.replace(/^0{1,}/, '0'); // "000123" → "0123"
   numStr.replace(/^0+/, '') 是通过 ​正则表达式移除字符串开头连续的零
   0+：匹配一个或多个连续的零

10 、
    forEach 不能使用 continue 和 break ，
        可以使用 return 或 return false 跳出循环，
    效果与 for 中 continue 一样，但是该方法无法一次结束所有循环

    every()：every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。
    some()：some() 方法测试数组中是不是至少有 1 个元素通过了被提供的函数测试。它返回的是一个布尔值。
    find()：find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。
    findIndex()：findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。

11、
    js 整数最多位数 15

    最大的整数就是2的32次方减1
    即 2 ** 32 - 1
    书上在介绍数组索引时也能佐证,因为数组的索引是整数,
    最大的索引就是 2 ** 32 - 1 即4294967295

12、字符串下标去除 str.slice(0, index) + str.slice(index + 1)

13、 bom: window , screen , navigator, location, history

14、目录
    __dirname 是相对于当前模块的目录，
    而 process.cwd() 是整个应用程序的当前工作目录

15、
    splice() 方法用于添加或删除数组中的元素。

    var fruits = ["Banana", "Orange", "Apple", "Mango"];
    fruits.splice(2,0,"Lemon","Kiwi");


    fruits 输出结果：

    Banana,Orange,Lemon,Kiwi,Apple,Mango

16， 字符串和数字， + 偏好 字符串， > 偏好 数字

17、实例上的__proto__ == 构造函数上的prototype

18、
    let numsSet = new Set(nums);
    let numsArray = Array.from(numsSet); // 将 Set 转换为数组

    获取set的第一个元素
    // only get the first item ✅
    const [first] = set;

    // iterator ✅
    const first = set.keys().next().value;


19、 数组推导：[ expression for (variable in object) if (condition)] 

20、String.fromCharCode(s[0].charCodeAt(0) - 1);
    charCodeAt 字符串转化为utf-16数字
    fromCharCode utf-16数字转化为字符串

21、遍历
    1. for...in经常被用来遍历一个object，
    它可以遍历一个对象的所有非Symbol、可枚举的属性（包括原型链上的属性）。

        自有属性、继承属性、枚举属性、不可枚举属性


    2.  for...of 循环是 JavaScript 编程中非常实用和方便的语法结构，
    用途：遍历可迭代对象（Iterable）的值。
    可以用于遍历数组、字符串、Map、Set 等数据结构，
    数组、字符串、Map、Set、TypedArray、arguments 等实现了 [Symbol.iterator] 接口的对象。
    以及生成器函数生成的迭代器和其他支持迭代器协议的对象

    3. Object.keys遍历
    Object.keys()会返回一个对象所有的可枚举属性。与in操作符不同的是，
    Object.keys不会去检查原型链上的那些属性
    Object.values();
    Object.entries();

    4.
    遍历，一般数字会按大小顺序， 字符串和symbol会按加入时间 

    遍历对象（{}）：使用 for...in（注意过滤原型属性）。
    遍历数组、字符串、Map、Set 等可迭代对象：使用 for...of。
    普通对象无法用 for...of，除非手动实现 [Symbol.iterator] 接口。

22、await, async 是自动执行生成器函数的语法糖，
    async/await 是由 generator函数 来实现的（yield *）
    async 函数返回一个 Promise 对象


23、 截取字符串的方法，slice 和 substring 的区别
    slice：
    用于从字符串或数组中提取指定范围的内容。
    支持负数参数，负数表示从末尾开始计算。
    'abcdef'.slice(1, 4); // 'bcd'
    'abcdef'.slice(-3);   // 'def'

    substring：
    用于提取字符串中两个指定索引之间的字符。
    不支持负数参数，负数会被当作 0 处理。
    'abcdef'.substring(1, 4); // 'bcd'
    'abcdef'.substring(-3);   // 'abc'
24、判断是否是数组
    方法 1： object.prototype.toString()
    object.prototype.toString().call(obj).slice(8, -1) === "Array"

    object.prototype.toString() 方法可按 [object xxxx] 的形式返回调用者的类型。此时的调用者为 object.prototype。
    不可以直接使用 obj.toString()， 因为所有数据类型都重写了 toString() 方法，如 new Array([1,2,3]).toString() 的结果为 1, 2, 3。
    因此，我们可以通过 call() 改变调用者的指向，来确保调用的是重写前的 toString 方法，且调用者是我们需要判断的变量。

    方法 2：使用原型链判断

    let instance = new fn();
    console.log(fn.prototype.constructor === fn) // true: 原型对象含一个指针指向其构造函数
    console.log(instance.__proto__ === fn.prototype) // true

    方法 3：Array.isArray(obj)

25、为什么使用语义化标签？
    提高网页的可读性和结构化
    有助于搜索引擎优化（SEO）
    无障碍支持

26. 递归：​栈溢出错误
	function foo() {
	foo(); // 每次调用都会再次触发 foo()
	}
	foo(); // 初始调用


	这段代码会引发 ​栈溢出错误（Maximum call stack size exceeded）​，
	因为函数 foo 无限递归调用自身，导致调用栈超出 JavaScript 引擎的限制。

	递归需要有退出条件, 可以用尾调用优化

27. 冒泡: mouseOver 和 mouseOut 事件会冒泡（父元素也会响应这个事件），而 mouseEnter 和 mouseLeave 不会冒泡。